<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Algorithms - Tag - Jiabin&#39;s Blog</title>
        <link>https://daijiabin.github.io/tags/algorithms/</link>
        <description>Algorithms - Tag - Jiabin&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 15 Mar 2021 09:04:18 &#43;0100</lastBuildDate><atom:link href="https://daijiabin.github.io/tags/algorithms/" rel="self" type="application/rss+xml" /><item>
    <title>Algorithms Dynamic Programming</title>
    <link>https://daijiabin.github.io/algorithms-dynamic-programming/</link>
    <pubDate>Mon, 15 Mar 2021 09:04:18 &#43;0100</pubDate>
    <author>Author</author>
    <guid>https://daijiabin.github.io/algorithms-dynamic-programming/</guid>
    <description><![CDATA[Algorithms 03 when it&rsquo;s used   Maximum, Minimum
  judge, if Something&rsquo;s possible
  calculate the Amount of the Plans
  when it&rsquo;s NOT used   specific Plan instead of the Amount of Plans ( Plaindrome Partitioning )
  Input is a Set instead of a Sequence ( Longest Consecutive Sequence )
  4 Points   Defination of States
  Transform-Function]]></description>
</item><item>
    <title>Algorithms Devide and Conquer</title>
    <link>https://daijiabin.github.io/algorithms-devide-and-conquer/</link>
    <pubDate>Mon, 08 Mar 2021 08:13:23 &#43;0100</pubDate>
    <author>Author</author>
    <guid>https://daijiabin.github.io/algorithms-devide-and-conquer/</guid>
    <description><![CDATA[Algorithms 02 Traverse vs. Divide &amp; Conquer   both Recursive
  Result in Parameter vs. Result in return Value
  Top-down vs. Bottom-up
  Basic Usage   Merge Sort / Quick Sort
  Almost 90% Binary Tree Problems
  Merge Sort &amp; Quick Sort   Merge Sort
  Quick Sort
  Exercises on LeetCode   LeetCode 104. Maximum Depth of Binary Tree]]></description>
</item><item>
    <title>Algorithms: Binary Search</title>
    <link>https://daijiabin.github.io/algorithms-binary-search/</link>
    <pubDate>Sun, 07 Mar 2021 08:57:20 &#43;0100</pubDate>
    <author>Author</author>
    <guid>https://daijiabin.github.io/algorithms-binary-search/</guid>
    <description><![CDATA[Algorithms 01 Highlight of BS  with the Judge-setence if we can transform a Problem from O(n) to O(n / 2)  4 Points   The Thought is to shrank Array nums into 2 Numbers -&gt; while-loop with start + 1 &lt; end
  update mid -&gt; mid = start + (end - start) / 2
  don&rsquo;t be lazy: 3 case -&gt; ==, &lt; , &gt;]]></description>
</item><item>
    <title>Algorithms -- Recursion</title>
    <link>https://daijiabin.github.io/algorithms/</link>
    <pubDate>Sun, 17 Jan 2021 16:51:37 &#43;0100</pubDate>
    <author>Author</author>
    <guid>https://daijiabin.github.io/algorithms/</guid>
    <description><![CDATA[Ideas Recursion   What important is, NEVER JUMP INTO RECURSION.
  Actually&hellip; If it&rsquo;s possible, you can jump into it&hellip; (Well&hellip; You can take a try:) )
  In a Word, what the Blog above says, is that you must make sure that you know the very Defination of your Recursion Function, and trust that it can finish its Work perfectly.
  1. Recursion in List   Figure out what does your Function proceedure with, what kind of value will it return.]]></description>
</item></channel>
</rss>
