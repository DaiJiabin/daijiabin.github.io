[{"categories":["TUD"],"content":"03. Fuzzing ","date":"2021-05-02","objectID":"/sft/:1:0","tags":["Kurse"],"title":"Software Fault Tolerance","uri":"/sft/"},{"categories":["TUD"],"content":"Definition A way to discover bugs in software by providing randomised inputs to programs to find test cases that cause a crash ","date":"2021-05-02","objectID":"/sft/:1:1","tags":["Kurse"],"title":"Software Fault Tolerance","uri":"/sft/"},{"categories":["TUD"],"content":"Goal Find crashes Find abnormal behavior Find security vulnerabilities ","date":"2021-05-02","objectID":"/sft/:1:2","tags":["Kurse"],"title":"Software Fault Tolerance","uri":"/sft/"},{"categories":["TUD"],"content":"Testing variants Positive testing Test features Negative testing Test if the system does things it is not supposed to do Fuzzing belongs to negative testing ","date":"2021-05-02","objectID":"/sft/:1:3","tags":["Kurse"],"title":"Software Fault Tolerance","uri":"/sft/"},{"categories":["TUD"],"content":"Fuzzing vs. Random testing Random testing is a simple version of fuzzing Problem of random testing: Coverage increases slowly Fuzzing: try to generate test cases in a smarter, more efficient way ","date":"2021-05-02","objectID":"/sft/:1:4","tags":["Kurse"],"title":"Software Fault Tolerance","uri":"/sft/"},{"categories":["TUD"],"content":"Components 1. Generator 1.1 Tasks Testing inputs to drive SUT Different approaches on how to generate the input 1.2 Types Mutative generator + Start with a sample input + Mutate a part of it + Good for highly structured inputs - Less Intelligence - Less human effort to understand protocols \u0026 interfaces Generative generator Generate the test cases from scratch Higher level of coverage More effort, if based on templates or grammars 1.3 Different production approach Oblivious fuzzer Randomly mutate/generate data Similar to random testing Template based Provide an input template Modify/generate only those parts that are allowed by the template Simple interface: minimal understanding of the structure accepted by SUT Block based Data represented as nested data blocks of varying types as opposed to string sequences(template based) Grammer based Covers some part of input language Heuristic based Better than complete ramdom(?) Protocol fuzzers Protocol description, not only grammar 2. Delivery machanism Presents the output of the fuzz generator as input to the SUT i.e., file, mouse, etc. 3. Monitoring system Observing the SUT and detection of errors that arise as input is presented ### ","date":"2021-05-02","objectID":"/sft/:1:5","tags":["Kurse"],"title":"Software Fault Tolerance","uri":"/sft/"},{"categories":["TUD"],"content":"03. ADED ","date":"2021-05-02","objectID":"/asise/:1:0","tags":["Kurse"],"title":"ASiSE","uri":"/asise/"},{"categories":["TUD"],"content":"What is ADED A nalyse role: existing technologies, backgrounds, problems D esign role: new technologies E valuate necessary for technical papers a technical thesis must be technical( achieve and demonstrate a technical result ) success factors have to be analyzed to know whether a result is really needed role: show why the new solution is superior; use success cretiria D iffuse by writing: a design pattern, a report by demonstrating a software prototype role: popularize the research results; demonstration for creating vision ","date":"2021-05-02","objectID":"/asise/:1:1","tags":["Kurse"],"title":"ASiSE","uri":"/asise/"},{"categories":["TUD"],"content":"Tasks for each Analyse Design Evaluate(Role?) Diffuse problem analysis; automation or optimization hypothesis; success factor analysis requirements of the solution; solution design; design alternatives, assessment and selection; architecture development testing the research hypothesis by experiments; benchmarking; interpretation of the experiments; documenting the limits of the technology structuring; drafting; revision; diffuse ","date":"2021-05-02","objectID":"/asise/:1:2","tags":["Kurse"],"title":"ASiSE","uri":"/asise/"},{"categories":["TUD"],"content":"AD-R-DE for techinical science thesis R here represents “Realize” For technical science ( in particular SE ), a realization phase is required. Tasks for realization phase realize the architecture tune the system stabilize the system for better quality Other variants see slides. ","date":"2021-05-02","objectID":"/asise/:1:3","tags":["Kurse"],"title":"ASiSE","uri":"/asise/"},{"categories":["TUD"],"content":"Standard Structure of a technical science thesis Show clearly, which part is from you and which part is not(background). Main part is divided in technology and evaluation part Structure see below: The structure of a scientific thesis is related to the chapters, write chapter by chapter Start with background and literature/state of art chapters from the orientation phase Develop technical solution and write it up in a main techinical contribution chapter Validate with an evaluation in parallel repeat ","date":"2021-05-02","objectID":"/asise/:2:0","tags":["Kurse"],"title":"ASiSE","uri":"/asise/"},{"categories":["TUD"],"content":"Analysis ","date":"2021-05-02","objectID":"/asise/:3:0","tags":["Kurse"],"title":"ASiSE","uri":"/asise/"},{"categories":["TUD"],"content":"Orientation analysis and idea generation Semantic Nets (simple concept maps) A semantic net draws objects and their relationships and action in a graph distinguished relationships: is-a, has-a, owns-a Concept Maps Shows several concepts and their relations. Usually, one starts with several central concepts in the middle of a page and collects associasions. See below: Concept Maps is a method for analysis, idea generation and structuring A concept map is a model of problems, knowledges, goals, solution ideas Enriches semantic nets with pictures and figures Clustering Helps to develop hierarchic, logical structures A node-labeled concept map with one root in the middle of the page Called a mindmap if the cluster is a tree Mindmaps A node- or edge-labeled association tree Line/Row Hierarchy (Q-A-Hierarchy) From a mindmap or structure tree, a row hierarchy can be formed with main thesis and arguments Phrase the main point as a question, and let the arguments answer the question ","date":"2021-05-02","objectID":"/asise/:3:1","tags":["Kurse"],"title":"ASiSE","uri":"/asise/"},{"categories":["TUD"],"content":"Problem analysis with questions The honset serving men, 7 basic questions who; what; how; where; when; why; for what/to which end Integrate into idea generation techniques: Analyze problems: “why” and “which end” Generate solution ideas: “how to achieve” Structure the available knowledge and literature: “what do we know” ","date":"2021-05-02","objectID":"/asise/:3:2","tags":["Kurse"],"title":"ASiSE","uri":"/asise/"},{"categories":["TUD"],"content":"04. information gathering ","date":"2021-05-02","objectID":"/asise/:4:0","tags":["Kurse"],"title":"ASiSE","uri":"/asise/"},{"categories":["TUD"],"content":"4.1 Data, information, knowledge aquisition in science What is DIKW model D ata I nformation K nowledge W isdom Above are what science about Natural science: find data and interprete them into knowledge Technical science: use knowledge to solve problems, but need to be wise(i.e., nuclear energy ). The knowledge aquisition model from spinner Knowledge is context-dependent and comes from information by interpretation Answering questions creates knowledge. Knowledge is what remains after answering questions Typical questions for interpretation About sender About context About receiver ","date":"2021-05-02","objectID":"/asise/:4:1","tags":["Kurse"],"title":"ASiSE","uri":"/asise/"},{"categories":["TUD"],"content":"4.2 Reading process with RIK What is RIK R elevance check I nformation K nowledge aquisition Stopping all the way and not wasting time Structured along the DIKW pyramid and the spinner IK aquisition process 4.2.1 Relevance check SWOT analysis For strategic decisions of thesis and research Try to combine with “6-honest-men” Killer App analysis Investigates for a product or a research paper, whether it’s needed, it’s comprehensive Attractive-Product $=$ Need $\\times$ Comprehensibility 4.2.2 Information aquisition 4.2.3 Knowledge aquisition ","date":"2021-05-02","objectID":"/asise/:4:2","tags":["Kurse"],"title":"ASiSE","uri":"/asise/"},{"categories":["TUD"],"content":"4.3 Other reading methods ","date":"2021-05-02","objectID":"/asise/:4:3","tags":["Kurse"],"title":"ASiSE","uri":"/asise/"},{"categories":["TUD"],"content":"4.4 Methods to recite for knowledge acquisition ","date":"2021-05-02","objectID":"/asise/:4:4","tags":["Kurse"],"title":"ASiSE","uri":"/asise/"},{"categories":["TUD"],"content":"4.5 Information gathering ","date":"2021-05-02","objectID":"/asise/:4:5","tags":["Kurse"],"title":"ASiSE","uri":"/asise/"},{"categories":["TUD"],"content":"4.6 Writing literature analysis papers ","date":"2021-05-02","objectID":"/asise/:4:6","tags":["Kurse"],"title":"ASiSE","uri":"/asise/"},{"categories":["Tool"],"content":"Git Notes ","date":"2021-04-29","objectID":"/git-learn/:1:0","tags":["Tool"],"title":"Git Learn","uri":"/git-learn/"},{"categories":["TUD"],"content":"Try to write some Notes here Not FREE. Two threads will never enter the critical section at the same time(mutual exclusion) - safety If two threads try to enter critical section, eventually one of them will succeed - Liveness ","date":"2021-04-26","objectID":"/note2021/:1:0","tags":["Kurse"],"title":"Note2021","uri":"/note2021/"},{"categories":["TUD"],"content":"Some Definitions ","date":"2021-04-26","objectID":"/haupt-seminar/:1:0","tags":["Kurse"],"title":"Haupt Seminar","uri":"/haupt-seminar/"},{"categories":["TUD"],"content":"Network Edge Where devices or local network interfaces with Internet ","date":"2021-04-26","objectID":"/haupt-seminar/:1:1","tags":["Kurse"],"title":"Haupt Seminar","uri":"/haupt-seminar/"},{"categories":["TUD"],"content":"Fog/Edge/Mobile-Edge Computing Fog/Edge Computing is a distributed computing paradigm that brings data storage and computation closer to where it is needed to improve the response time and save bandwidth. Mobile Edge Computing is a network archietecture which enables the cloud computing capabilities and IT services at the edge of the network. ","date":"2021-04-26","objectID":"/haupt-seminar/:1:2","tags":["Kurse"],"title":"Haupt Seminar","uri":"/haupt-seminar/"},{"categories":["TUD"],"content":"Software-Defined-Network Features: Decoupling the data plane and control plane Advantages: Get a global overview of the network from data plane Components: SDN controller Gather the entire behaviors of network, orchestration \u0026 resource management SDN-based edge server Provide computation and storage for vehicles, store regional road information, provide emergency service SDN micro based station Running OpenFlow, delivering edge services SDN-base road side units Running OpenFlow, exchange data with vehicles SDN-based smart vehicle On-Board Unit and OpenFlow, end user Issues: Security Scalability Elasticity ","date":"2021-04-26","objectID":"/haupt-seminar/:1:3","tags":["Kurse"],"title":"Haupt Seminar","uri":"/haupt-seminar/"},{"categories":["TUD"],"content":"Network-Function-Virtualization Features: With the help of IT virtualization technology, virtualize the entire classes of network node functions into building blocks that may connect, or chain together, to create communication services. ","date":"2021-04-26","objectID":"/haupt-seminar/:1:4","tags":["Kurse"],"title":"Haupt Seminar","uri":"/haupt-seminar/"},{"categories":["TUD"],"content":"Advices from Mr.Sommer So, to start with: you managed to successfully give your kick-off presentation, so you’re still in the seminar Please also keep in mind that the kick-off presentation is supposed to present one paper in detail. This is totally different to the thesis talk at the end of the seminar, which will require you to give a high level overview of your topic In your kick-off presentation you managed to present the contents of the paper, but I was somewhat confused that you stuck so closely to how the paper was laid out - it’s almost like you summarized every 4 paragraphs of the paper into one sentence of your own, then presented that Of course, that’s enough to pass the first stage of the seminar, but it’s very far removed from what you are supposed to do in the final presentation. In the seminar talk (or the seminar thesis), if you find yourself explaining parts of a single paper, you probably went into too much detail. What is required of you in the seminar talk/thesis is to discuss commonalities of multiple papers (or differences of these papers) With this out of the way, let me briefly move on the the talk itself: Your presentation was eloquent and easy to follow, the slide design was simple, but very efficient You could easily make your (virtual) presentation more engaging if you could look at the audience (i.e., your lens) more often Lastly, I was missing a footer on your slides - a common line on every slide (that shows 1) who’s talking, 2) what they are talking about, and 3) which slide number is currently presented) helps follow your presentation and (most importantly) makes it easier to ask questions that is, the audience can raise a question like “could you please explain the picture on slide 5” as opposed to “can you please go back a slide; no, forward; one more; one more; okay, maybe it was the other way”… which wastes a lot of time during Q\u0026A I can also recommend asking Dr. Hensel for feedback - he took very good notes as well ","date":"2021-04-26","objectID":"/haupt-seminar/:1:5","tags":["Kurse"],"title":"Haupt Seminar","uri":"/haupt-seminar/"},{"categories":["Learn"],"content":"Algorithms 03 ","date":"2021-03-15","objectID":"/algorithms-dynamic-programming/:0:0","tags":["Algorithms"],"title":"Algorithms Dynamic Programming","uri":"/algorithms-dynamic-programming/"},{"categories":["Learn"],"content":"when it’s used Maximum, Minimum judge, if Something’s possible calculate the Amount of the Plans ","date":"2021-03-15","objectID":"/algorithms-dynamic-programming/:1:0","tags":["Algorithms"],"title":"Algorithms Dynamic Programming","uri":"/algorithms-dynamic-programming/"},{"categories":["Learn"],"content":"when it’s NOT used specific Plan instead of the Amount of Plans ( Plaindrome Partitioning ) Input is a Set instead of a Sequence ( Longest Consecutive Sequence ) ","date":"2021-03-15","objectID":"/algorithms-dynamic-programming/:2:0","tags":["Algorithms"],"title":"Algorithms Dynamic Programming","uri":"/algorithms-dynamic-programming/"},{"categories":["Learn"],"content":"4 Points Defination of States Transform-Function Initialization ( Start ) Answer ( End ) ","date":"2021-03-15","objectID":"/algorithms-dynamic-programming/:3:0","tags":["Algorithms"],"title":"Algorithms Dynamic Programming","uri":"/algorithms-dynamic-programming/"},{"categories":["Learn"],"content":"Types of DP Coordinate Sequence Double-Sequence ","date":"2021-03-15","objectID":"/algorithms-dynamic-programming/:4:0","tags":["Algorithms"],"title":"Algorithms Dynamic Programming","uri":"/algorithms-dynamic-programming/"},{"categories":["Learn"],"content":"Some Tips when initialize a 2D-Matrix, initialize its 1.st Row and 1.st Column. ","date":"2021-03-15","objectID":"/algorithms-dynamic-programming/:5:0","tags":["Algorithms"],"title":"Algorithms Dynamic Programming","uri":"/algorithms-dynamic-programming/"},{"categories":["Learn"],"content":"Exercises on LeetCode ","date":"2021-03-15","objectID":"/algorithms-dynamic-programming/:6:0","tags":["Algorithms"],"title":"Algorithms Dynamic Programming","uri":"/algorithms-dynamic-programming/"},{"categories":["Learn"],"content":"Coordinate LeetCode 45. Jump Game II class Solution { public int jump(int[] nums) { int size = nums.length; int[] f = new int[size]; f[0] = 0; for(int i = 1; i \u003c size; i++){ f[i] = Integer.MAX_VALUE; for(int j = 0; j \u003c i; j++){ if(f[j] != Integer.MAX_VALUE \u0026\u0026 j + nums[j] \u003e= i){ f[i] = f[j] + 1; // break; } } } return f[size - 1]; } } LeetCode 55. Jump Game class Solution { public boolean canJump(int[] nums) { boolean[] f = new boolean[nums.length]; f[0] = true; for(int i = 1; i \u003c nums.length; i++){ for(int j = 0; j \u003c i; j++){ if(f[j] \u0026\u0026 j + nums[j] \u003e= i){ f[i] = true; break; } } } return f[nums.length - 1]; } } LeetCode 62. Unique Paths class Solution { public int uniquePaths(int m, int n) { int[][]f = new int[m][n]; for(int i = 0; i \u003c m; i++) f[i][0] = 1; for(int j = 0; j \u003c n; j++) f[0][j] = 1; for(int i = 1; i \u003c m; i++) for(int j = 1; j \u003c n; j++) f[i][j] = f[i - 1][j] + f[i][j - 1]; return f[m - 1][n - 1]; } } LeetCode 64. Minimum Path Sum class Solution { public int minPathSum(int[][] grid) { if(grid == null || grid.length == 0) return 0; int m = grid.length, n = grid[0].length; int[][] f = new int[m][n]; for(int i = 0; i \u003c m; i++) for(int j = 0; j \u003c n; j++) f[i][j] = Integer.MAX_VALUE; f[0][0] = grid[0][0]; // Initialization for(int i = 1; i \u003c m; i++) f[i][0] = f[i - 1][0] + grid[i][0]; for(int j = 1; j \u003c n; j++) f[0][j] = f[0][j - 1] + grid[0][j]; // DP for(int i = 1; i \u003c m; i++) for(int j = 1; j \u003c n; j++) f[i][j] = Math.min(f[i - 1][j], f[i][j - 1]) + grid[i][j]; return f[m - 1][n - 1]; } } LeetCode 120. Triangle Traverse ( Time Limit Exceeded ) class Solution { private int best = Integer.MAX_VALUE; private void traverse(int x, int y, int sum, List\u003cList\u003cInteger\u003e\u003e triangle){ if(x == triangle.size()){ if(sum \u003c best) best = sum; return; } traverse(x + 1, y, sum + triangle.get(x).get(y), triangle); traverse(x + 1, y + 1, sum + triangle.get(x).get(y), triangle); } public int minimumTotal(List\u003cList\u003cInteger\u003e\u003e triangle) { traverse(0, 0, 0, triangle); return best; } } Divide \u0026 Conquer ( Time Limit Exceeded ) class Solution { private int divideConquer(int x, int y, List\u003cList\u003cInteger\u003e\u003e triangle){ if(x == triangle.size()) return 0; return triangle.get(x).get(y) + Math.min(divideConquer(x + 1, y, triangle), divideConquer(x + 1, y + 1, triangle)); } public int minimumTotal(List\u003cList\u003cInteger\u003e\u003e triangle) { return divideConquer(0, 0, triangle); } } Divide \u0026 Conquer with Memorization class Solution { private int divideConquer(int x, int y, List\u003cList\u003cInteger\u003e\u003e triangle, int[][] hash){ if(x == triangle.size()) return 0; if(hash[x][y] != Integer.MAX_VALUE) return hash[x][y]; hash[x][y] = triangle.get(x).get(y) + Math.min(divideConquer(x + 1, y, triangle, hash), divideConquer(x + 1, y + 1, triangle, hash)); return hash[x][y]; } public int minimumTotal(List\u003cList\u003cInteger\u003e\u003e triangle) { int m = triangle.size(); int n = triangle.get(m - 1).size(); int[][] hash = new int [m][n]; for(int i = 0; i \u003c m; i++){ for(int j = 0; j \u003c n; j++) hash[i][j] = Integer.MAX_VALUE; } return divideConquer(0, 0, triangle, hash); } } DP class Solution { public int minimumTotal(List\u003cList\u003cInteger\u003e\u003e triangle) { int n = triangle.size(); int[][] f = new int[n][n]; f[0][0] = triangle.get(0).get(0); // Initialize the 2 Edges of the Triangle, Start for(int i = 1; i \u003c n; i++){ f[i][0] = f[i - 1][0] + triangle.get(i).get(0); f[i][i] = f[i - 1][i - 1] + triangle.get(i).get(i); } // DP, Top to Bottom for(int i = 1; i \u003c n; i++){ for(int j = 1; j \u003c i; j++) f[i][j] = Math.min(f[i - 1][j], f[i - 1][j - 1]) + triangle.get(i).get(j); } int answer = Integer.MAX_VALUE; for(int i = 0; i \u003c n; i++) answer = Math.min(answer, f[n - 1][i]); return answer; } } LeetCode 300. Longest Increasing Subsequence class Solution { public int lengthOfLIS(int[] nums) { if(nums == null || nums.length == 0) return 0; int[] f = new int[nums.length]; // Array f storages the LIS in i_th Location int max = 0; for(int i = 0; i \u003c nums.length; i++){ f[i] = 1; // the for-loop below picks out the maximum in f[j], j in","date":"2021-03-15","objectID":"/algorithms-dynamic-programming/:6:1","tags":["Algorithms"],"title":"Algorithms Dynamic Programming","uri":"/algorithms-dynamic-programming/"},{"categories":["Learn"],"content":"Subsequence single State: f[i] represents Alphabets / Numbers / Locations before i ( different from LIS, ont i_th ) Function: f[i] = f[j]…( j \u003c i ) Initialization: f[0]… Answer: f[n - 1]… LeetCode 132. Palindrome Partitioning II (HARD) class Solution { private boolean isPalindrome(String s, int start, int end){ for(int i = start, j = end; i \u003c j; i++, j--){ if(s.charAt(i) != s.charAt(j)) return false; } return true; } private boolean[][] getIsPalindrome(String s){ // this Function is DP, too // DP-Type: subArea boolean [][] isPalindrome = new boolean[s.length()][s.length()]; // single Alphabet is palindrom for(int i = 0; i \u003c s.length(); i++) isPalindrome[i][i] = true; // judge if every 2 Alphabets are palindrom for(int i = 0; i \u003c s.length() - 1; i++) isPalindrome[i][i + 1] = (s.charAt(i) == s.charAt(i + 1)); for(int length = 2; length \u003c s.length(); length++){ // Length of subArea, from 3 to n // f[i][j] depends on f[i + 1][j - 1] for(int start = 0; start + length \u003c s.length(); start++){ isPalindrome[start][start + length] = isPalindrome[start + 1][start + length - 1] \u0026\u0026 s.charAt(start) == s.charAt(start + length); } } return isPalindrome; } public int minCut(String s) { if(s == null || s.length() == 0) return 0; boolean[][] isPalindrome = getIsPalindrome(s); int[] f = new int[s.length() + 1]; // Initialization // worst Case: we seperate a String into single Alphabet. // we have 5 Fingers and 4 Gaps among them for(int i = 0; i \u003c= s.length(); i++) f[i] = i - 1; // but why f[0] = -1? // Case \"abba\" // DP below for(int i = 1; i \u003c= s.length(); i++){ for(int j = 0; j \u003c i; j++){ // if subString(j, i-1) is palindrom. // (j+1)_th to i_th subString. if(isPalindrome[j][i - 1]) f[i] = Math.min(f[i], f[j] + 1); // we can also write it this way: // if(isPalindrome(s, j, i - 1)) // by using 2D-Matrix we optimize the Complexity to O(1). } } return f[s.length()]; } } LeetCode 139. Word Break class Solution { private int getMaxLength(List\u003cString\u003e wordDict){ int maxLength = 0; for(String word:wordDict){ maxLength = Math.max(maxLength, word.length()); } return maxLength; } public boolean wordBreak(String s, List\u003cString\u003e wordDict) { if(s == null || s.length() == 0) return true; int maxLength = getMaxLength(wordDict); boolean[] canSegment = new boolean[s.length() + 1]; canSegment[0] = true; for(int i = 1; i \u003c= s.length(); i++){ canSegment[i] = false; for(int lastWordLength = 1; lastWordLength \u003c= maxLength \u0026\u0026 lastWordLength \u003c= i; lastWordLength++){ if(!canSegment[i - lastWordLength]) continue; String word = s.substring(i - lastWordLength, i); if(wordDict.contains(word)){ canSegment[i] = true; break; } } } return canSegment[s.length()]; } } Double State: f[i][j] represents Alphabets before i in the first Sequence and Alphabets before j in the second Sequence. Function: f[i][j] = Pairing-Relationship between i and j Initialize: f[i][0] and f[0][i] Answer: f[s1.length()][s2.length()] LeetCode 72. Edit Distance (HARD) public class Solution { public int minDistance(String word1, String word2) { int n = word1.length(); int m = word2.length(); int[][] dp = new int[n+1][m+1]; for (int i = 0; i \u003c m + 1; i++) { dp[0][i] = i; } for (int i = 0; i \u003c n + 1; i++) { dp[i][0] = i; } for (int i = 1; i \u003c n + 1; i++) { for (int j = 1; j \u003c m + 1; j++) { if (word1.charAt(i - 1) == word2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1]; }else{ dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])); } } } return dp[n][m]; } } LeetCode 97. Interleaving String class Solution { public boolean isInterleave(String s1, String s2, String s3) { if(s1.length() + s2.length() != s3.length()) return false; boolean[][] interleaved = new boolean[s1.length() + 1][s2.length() + 1]; interleaved[0][0] = true; for(int i = 1; i \u003c= s1.length(); i++){ if(s3.charAt(i - 1) == s1.charAt(i - 1) \u0026\u0026 interleaved[i - 1][0]) interleaved[i][0] = true; } for(int j = 1; j \u003c= s2.length(); j++){ if(s3.charAt(j - 1) == s2.charAt(j - 1) \u0026\u0026 interleaved[0][j - 1]) interleaved[0][j] = true; } ","date":"2021-03-15","objectID":"/algorithms-dynamic-programming/:6:2","tags":["Algorithms"],"title":"Algorithms Dynamic Programming","uri":"/algorithms-dynamic-programming/"},{"categories":["Learn"],"content":"Algorithms 02 ","date":"2021-03-08","objectID":"/algorithms-devide-and-conquer/:0:0","tags":["Algorithms"],"title":"Algorithms Devide and Conquer","uri":"/algorithms-devide-and-conquer/"},{"categories":["Learn"],"content":"Traverse vs. Divide \u0026 Conquer both Recursive Result in Parameter vs. Result in return Value Top-down vs. Bottom-up ","date":"2021-03-08","objectID":"/algorithms-devide-and-conquer/:1:0","tags":["Algorithms"],"title":"Algorithms Devide and Conquer","uri":"/algorithms-devide-and-conquer/"},{"categories":["Learn"],"content":"Basic Usage Merge Sort / Quick Sort Almost 90% Binary Tree Problems ","date":"2021-03-08","objectID":"/algorithms-devide-and-conquer/:2:0","tags":["Algorithms"],"title":"Algorithms Devide and Conquer","uri":"/algorithms-devide-and-conquer/"},{"categories":["Learn"],"content":"Merge Sort \u0026 Quick Sort Merge Sort Quick Sort ","date":"2021-03-08","objectID":"/algorithms-devide-and-conquer/:3:0","tags":["Algorithms"],"title":"Algorithms Devide and Conquer","uri":"/algorithms-devide-and-conquer/"},{"categories":["Learn"],"content":"Exercises on LeetCode LeetCode 104. Maximum Depth of Binary Tree Divide \u0026 Conquer class Solution { // Divide \u0026 Conquer public int maxDepth(TreeNode root) { if(root == null) return 0; int left = maxDepth(root.left); int right = maxDepth(root.right); return Math.max(left, right) + 1; } } Recursion class Solution { private int depth = 0; public int maxDepth(TreeNode root) { if(root == null) return depth; traverse(root, 1); return depth; } private void traverse(TreeNode root, int curdepth){ if(root == null) return; if(curdepth \u003e depth) depth = curdepth; traverse(root.left, curdepth + 1); traverse(root.right, curdepth + 1); return; } } LeetCode 110. Balanced Binary Tree with Help of maxDepth class Solution { public boolean isBalanced(TreeNode root) { if(root == null) return true; int ldepth = depth(root.left); int rdepth = depth(root.right); if(Math.abs(ldepth - rdepth) \u003e 1) return false; return isBalanced(root.left) \u0026\u0026 isBalanced(root.right); } private int depth(TreeNode root){ if(root == null) return 0; int left = depth(root.left); int right = depth(root.right); return 1 + Math.max(left, right); } } Divide \u0026 Conquer ( Master it! ) class ResultType{ public boolean isBalanced; public int maxDepth; public ResultType(boolean isBalanced, int maxDepth){ this.isBalanced = isBalanced; this.maxDepth = maxDepth; } } class Solution { public boolean isBalanced(TreeNode root) { return helper(root).isBalanced; } private ResultType helper(TreeNode root){ if(root == null) return new ResultType(true, 0); ResultType left = helper(root.left); ResultType right = helper(root.right); if(!left.isBalanced || !right.isBalanced) return new ResultType(false, -1); if(Math.abs(left.maxDepth - right.maxDepth) \u003e 1) return new ResultType(false, -1); return new ResultType(true, Math.max(left.maxDepth, right.maxDepth) + 1); } } LeetCode 124. Binary Tree Maximum Path Sum (HARD) private class ResultType{ int singlePath, maxPath; // singlePath: from root to bottom, can include no Node // maxPath: maximum Path from any Node in Tree, // include at least 1 Node ResultType(int singlePath, int maxPath){ this.singlePath = singlePath; this.maxPath = maxPath; } } class Solution { private ResultType helper(TreeNode root){ if(root == null) return new ResultType(0, Integer.MIN_VALUE); // Divide ResultType left = helper(root.left); ResultType right = helper(root.right); // Conquer int singlePath = Math.max(left.singlePath, right.singlePath) + root.val; singlePath = Math.max(singlePath, 0); int maxPath = Math.max(left.maxPath, right.maxPath); maxPath = Math.max(maxPath, left.singlePath + right.singlePath + root.val); return new ResultType(singlePath, maxPath); } public int maxPathSum(TreeNode root) { ResultType result = helper(root); return result.maxPath; } } LeetCode 144. Binary Tree Preorder Traversal Recursion – DONNOT JUMP INTO RECURSION! class Solution { // Recursion public List\u003cInteger\u003e preorderTraversal(TreeNode root) { List\u003cInteger\u003e result = new ArrayList\u003cInteger\u003e(); traverse(root, result); return result; } private void tarverse(TreeNode root, List\u003cInteger\u003e result){ if(root == null) return; result.add(root.val); traverse(root.left, result); traverse(root.right, result); } } Iterative class Solution { // Iterative public List\u003cInteger\u003e preorderTraversal(TreeNode root) { List\u003cInteger\u003e result = new ArrayList\u003cInteger\u003e(); Stack\u003cTreeNode\u003e stack = new Stack\u003cTreeNode\u003e(); if(root == null) return result; stack.push(root); while(!stack.empty()){ TreeNode curr = stack.pop(); result.add(curr.val); // Here we must push right first, then left if(curr.right != null) stack.push(curr.right); // Because Stack is a FILO Data Structure if(curr.left != null) stack.push(curr.left); } return result; } } Divide and Conquer class Solution { // Divide and Conquer public List\u003cInteger\u003e preorderTraversal(TreeNode root) { List\u003cInteger\u003e result = new ArrayList\u003cInteger\u003e(); if(root == null) return result; // Divide List\u003cInteger\u003e left = preorderTraversal(root.left); List\u003cInteger\u003e right = preorderTraversal(","date":"2021-03-08","objectID":"/algorithms-devide-and-conquer/:4:0","tags":["Algorithms"],"title":"Algorithms Devide and Conquer","uri":"/algorithms-devide-and-conquer/"},{"categories":["Learn"],"content":"BFS in Binary Tree 2 Queues 2 Queues represent different Layers. 1 Queue + 1 Dummy Root Dummy Node represents the End of each Layer. 1 Queue ( BEST ) LeetCode 102. Binary Tree Level Order Traversal BFS class Solution { public List\u003cList\u003cInteger\u003e\u003e levelOrder(TreeNode root) { List result = new ArrayList(); if(root == null) return result; Queue\u003cTreeNode\u003e queue = new LinkedList\u003cTreeNode\u003e(); queue.offer(root); while(!queue.isEmpty()){ List\u003cInteger\u003e level = new ArrayList\u003cInteger\u003e(); int size = queue.size(); for(int i = 0; i \u003c size; i++){ TreeNode head = queue.poll(); level.add(head.val); if(head.left!= null) queue.offer(head.left); if(head.right != null) queue.offer(head.right); } result.add(level); } return result; } } DFS ( Understand it ) class Solution { public List\u003cList\u003cInteger\u003e\u003e levelOrder(TreeNode root) { List\u003cList\u003cInteger\u003e\u003e results = new ArrayList\u003cList\u003cInteger\u003e\u003e(); if(root == null) return results; int maxLevel = 0; while(true){ ArrayList\u003cInteger\u003e level = new ArrayList\u003cInteger\u003e(); dfs(root, level, 0, maxLevel); if(level.size() == 0) break; results.add(level); maxLevel++; } return results; } private void dfs(TreeNode root, ArrayList\u003cInteger\u003e level, int curtLevel, int maxLevel){ if(root == null || curtLevel \u003e maxLevel) return; if(curtLevel == maxLevel){ level.add(root.val); return; } dfs(root.left, level, curtLevel + 1, maxLevel); dfs(root.right, level, curtLevel + 1, maxLevel); } } LeetCode 173. Binary Search Tree Iterator class BSTIterator { private Stack\u003cTreeNode\u003e stack = new Stack\u003c\u003e(); private TreeNode curt; public BSTIterator(TreeNode root) { curt = root; } public int next() { while(curt != null){ stack.push(curt); curt = curt.left; } curt = stack.pop(); TreeNode node = curt; curt = curt.right; return node.val; } public boolean hasNext() { return (curt != null || !stack.isEmpty()); } } ","date":"2021-03-08","objectID":"/algorithms-devide-and-conquer/:5:0","tags":["Algorithms"],"title":"Algorithms Devide and Conquer","uri":"/algorithms-devide-and-conquer/"},{"categories":["Learn"],"content":"Valid BST LeetCode 98. Validate Binary Search Tree Recursion class Solution { // Inorder Traverse of BST, it ascends. private int lastVal = Integer.MIN_VALUE; private boolean firstNode = true; public boolean isValidBST(TreeNode root) { if(root == null) return true; if(!isValidBST(root.left)) return false; if(!firstNode \u0026\u0026 lastVal \u003e= root.val) return false; firstNode = false; lastVal = root.val; if(!isValidBST(root.right)) return false; return true; } } Divide \u0026 Conquer class ResultType{ boolean is_bst; int maxValue, minValue; public ResultType(boolean is_bst, int maxValue, int minValue){ this.is_bst = is_bst; this.maxValue = maxValue; this.minValue = minValue; } } class Solution { public boolean isValidBST(TreeNode root) { ResultType r = validateHelper(root); return r.is_bst; } private ResultType validateHelper(TreeNode root){ if(root == null) return new ResultType(true, Integer.MIN_VALUE, Integer.MAX_VALUE); ResultType left = validateHelper(root.left); ResultType right = validateHelper(root.right); if(!left.is_bst || !right.is_bst) return new ResultType(false, 0, 0); if(root.left != null \u0026\u0026 left.maxValue \u003e= root.val || root.right != null \u0026\u0026 right.minValue \u003c= root.val) // BST Feature // left child \u003c root // right chile \u003e root return new ResultType(false, 0, 0); return new ResultType(true, Math.max(root.val, right.maxValue), Math.min(root.val, left.minValue)); } } ","date":"2021-03-08","objectID":"/algorithms-devide-and-conquer/:6:0","tags":["Algorithms"],"title":"Algorithms Devide and Conquer","uri":"/algorithms-devide-and-conquer/"},{"categories":["Learn"],"content":"Algorithms 01 ","date":"2021-03-07","objectID":"/algorithms-binary-search/:0:0","tags":["Algorithms"],"title":"Algorithms: Binary Search","uri":"/algorithms-binary-search/"},{"categories":["Learn"],"content":"Highlight of BS with the Judge-setence if we can transform a Problem from O(n) to O(n / 2) ","date":"2021-03-07","objectID":"/algorithms-binary-search/:1:0","tags":["Algorithms"],"title":"Algorithms: Binary Search","uri":"/algorithms-binary-search/"},{"categories":["Learn"],"content":"4 Points The Thought is to shrank Array nums into 2 Numbers -\u003e while-loop with start + 1 \u003c end update mid -\u003e mid = start + (end - start) / 2 don’t be lazy: 3 case -\u003e ==, \u003c , \u003e at the End -\u003e nums[start] / nums[end] ? target ( watch the Sequence of start and end, see Codes below ) ","date":"2021-03-07","objectID":"/algorithms-binary-search/:2:0","tags":["Algorithms"],"title":"Algorithms: Binary Search","uri":"/algorithms-binary-search/"},{"categories":["Learn"],"content":"when it’s needed Optimize an O(N) Algorithm ( better than O(N) is fast only O(logN) ) ( rotated ) sorted Array ","date":"2021-03-07","objectID":"/algorithms-binary-search/:3:0","tags":["Algorithms"],"title":"Algorithms: Binary Search","uri":"/algorithms-binary-search/"},{"categories":["Learn"],"content":"Exercises on LeetCode ","date":"2021-03-07","objectID":"/algorithms-binary-search/:4:0","tags":["Algorithms"],"title":"Algorithms: Binary Search","uri":"/algorithms-binary-search/"},{"categories":["Learn"],"content":"Find the First Position end to mid, if possible, return start class Solution{ public int BinarySearch(int[] nums, int target){ if(nums == null || nums.length == 0) return -1; int start = 0, end = nums.length - 1; while(start + 1 \u003c end){// WATCH OUT int mid = start + (end - start) / 2; if(nums[mid] == target) end = mid; // WATCH OUT else if(nums[mid] \u003c target) start = mid; else end = mid; // WATCH OUT } if(nums[start] == target) // for the first Position, we caompare nums[start] first. return start; if(nums[end] == traget) return end; return -1; } } LeetCode 33. Search in Rotated Sorted Array class Solution { public int search(int[] nums, int target) { if(nums == null || nums.length == 0) return 0; int start = 0, end = nums.length - 1; while(start + 1 \u003c end){ int mid = start + (end - start) / 2; if(nums[mid] == target) return mid; if(nums[start] \u003c nums[mid]){ if(target \u003e= nums[start] \u0026\u0026 target \u003c= nums[mid]) end = mid; else start = mid; } else{ if(target \u003e= nums[mid] \u0026\u0026 target \u003c= nums[end]) start = mid; else end = mid; } } if(nums[start] == target) return start; else if(nums[end] == target) return end; else return -1; } } LeetCode 35. Search Insert Position class Solution { // Idea: find the first Element that \u003e= target. public int searchInsert(int[] nums, int target) { if(nums == null || nums.length == 0) return 0; int start = 0, end = nums.length - 1; while(start + 1 \u003c end){ int mid = start + (end - start) / 2; if(nums[mid] == target) end = mid; else if(nums[mid] \u003c target) start = mid; else end = mid; } if(nums[start] \u003e= target) return start; if(nums[end] \u003e= target) return end; return nums.length; } } LeetCode 153. Find Minimum in Rotated Sorted Array class Solution { public int findMin(int[] nums) { if(nums == null || nums.length == 0) return -1; int start = 0, end = nums.length - 1; int target = nums[end]; //Q: why set target here? why not nums[start]? while(start + 1 \u003c end){ int mid = start + (end - start) / 2; if(nums[mid] == target) start = mid; else if(nums[mid] \u003c target) end = mid; else if(nums[mid] \u003e target) start = mid; } if(nums[start] \u003c= nums[end]) return nums[start]; else return nums[end]; } } LeetCode 154. Find Minimum in Rotated Sorted Array II class Solution { public int findMin(int[] nums) { if(nums == null || nums.length == 0) return -1; int start = 0, end = nums.length - 1; while(start + 1 \u003c end){ int mid = start + (end - start) / 2; if(nums[mid] \u003e nums[end]) start = mid; else if(nums[mid] \u003c nums[end]) end = mid; else if(nums[mid] == nums[end]){ // Here we minimize the Boundary, but why? // In this Case, we cannot determine // start = mid or end = mid end--; // Here we cannot use start++; // e.g., [1,3,3] } } if(nums[start] \u003c= nums[end]) return nums[start]; return nums[end]; } } LeetCode 162. Find Peak Element class Solution { public int findPeakElement(int[] nums) { int start = 0, end = nums.length - 1; while(start + 1 \u003c end){ int mid = start + (end - start) / 2; if(nums[mid] \u003c nums[mid + 1]) //case 1 start = mid; else if(nums[mid] \u003c nums[mid - 1]) //case 2 end = mid; else if(nums[mid] \u003e nums[mid - 1] \u0026\u0026 nums[mid] \u003e nums[mid + 1]) //case 3 return mid; else //case 4 start = mid; // `end = mid;` works, too } if(nums[start] \u003c nums[end]) return end; else return start; } } LeetCode 278. First Bad Version public class Solution extends VersionControl { public int firstBadVersion(int n) { if(n == 0) return -1; int start = 0, end = n; while(start + 1 \u003c end){ int mid = start + (end - start) / 2; if(isBadVersion(mid)) end = mid; else if(!isBadVersion(mid)) start = mid; } if(isBadVersion(start)) return start; else return end; } } ","date":"2021-03-07","objectID":"/algorithms-binary-search/:4:1","tags":["Algorithms"],"title":"Algorithms: Binary Search","uri":"/algorithms-binary-search/"},{"categories":["Learn"],"content":"Find the Last Position start to mid, if possible, return end class Solution{ public int BinarySearch(int[] nums, int target){ if(nums == null || nums.length == 0) return -1; int start = 0, end = nums.length - 1; while(start + 1 \u003c end){// WATCH OUT int mid = start + (end - start) / 2; if(nums[mid] == target) start = mid; // WATCH OUT else if(nums[mid] \u003c target) start = mid; // WATCH OUT else end = mid; } if(nums[end] == traget) // for the last Position, we caompare nums[end] first. return end; // an Example, nums = {2, 2, 2}, target = 2. if(nums[start] == target) return start; return -1; } } LeetCode 69. Sqrt(x) class Solution { public int mySqrt(int x) { long start = 1, end = x; while(start + 1 \u003c end){ long mid = start + (end - start) / 2; if(mid * mid == x) start = mid; else if(mid * mid \u003e x) end = mid; else if(mid * mid \u003c x) start = mid; } if(end * end \u003c= x) return (int) end; return (int) start; } } LeetCode74. Search a 2D Matrix class Solution { // Idea: flatten 2D-Matrix into 1D-Matrix public boolean searchMatrix(int[][] matrix, int target) { if(matrix == null) return false; if(matrix.length == 0 || matrix[0].length == 0) return false; int row = matrix.length, column = matrix[0].length; int start = 0, end = row * column - 1; while(start + 1 \u003c end){ int mid = start + (end - start) / 2; int now = matrix[mid / column][mid % column]; if(now == target) return true; else if(now \u003c target) start = mid; else end = mid; } if(matrix[start / column][start % column] == target) return true; if(matrix[end / column][end % column] == target) return true; return false; } } a not so smart way to solve: row first, column then. class Solution { public boolean searchMatrix(int[][] matrix, int target) { if(matrix == null || matrix[0].length == 0) return false; int row = matrix.length; int column = matrix[0].length; // find row first int start = 0, end = row - 1; while(start + 1 \u003c end){ int mid = start + (end - start) / 2; if(matrix[mid][0] == target) return true; else if(matrix[mid][0] \u003c target) start = mid; else if(matrix[mid][0] \u003e target) end = mid; } // WATCH OUT if(matrix[end][0] \u003c= target) row = end; else if(matrix[start][0] \u003c= target) row = start; else return false; start = 0; end = column - 1; while(start + 1 \u003c end){ int mid = start + (end - start) / 2; if(matrix[row][mid] == target) return true; else if(matrix[row][mid] \u003c target) start = mid; else end = mid; } if(matrix[row][start] == target) return true; else if(matrix[row][end] == target) return true; else return false; } } ","date":"2021-03-07","objectID":"/algorithms-binary-search/:4:2","tags":["Algorithms"],"title":"Algorithms: Binary Search","uri":"/algorithms-binary-search/"},{"categories":["Learn"],"content":"Find Any Position Find and return, just do it:) ","date":"2021-03-07","objectID":"/algorithms-binary-search/:4:3","tags":["Algorithms"],"title":"Algorithms: Binary Search","uri":"/algorithms-binary-search/"},{"categories":["TUD"],"content":"Kurs Katalog Sommersemester 2021 ","date":"2021-03-06","objectID":"/2021-sose/:0:0","tags":["Kurse"],"title":"2021 Sose","uri":"/2021-sose/"},{"categories":["TUD"],"content":"INF-BAS3 Software- und Web-Engineering Component-based Software Engineering (2/2/0) Internet and Web Applications (2/2/0) Software Fault Tolerance (2/2/0) Softwaremanagement (2/2/0) Spatiotemporal Modeling and Simulation of Biological Systems (2/2/0) ","date":"2021-03-06","objectID":"/2021-sose/:0:1","tags":["Kurse"],"title":"2021 Sose","uri":"/2021-sose/"},{"categories":["TUD"],"content":"INF-BAS4 Systemarchitektur Internet and Web Applications (2/2/0) Software Fault Tolerance (2/2/0) Distributed Operating Systems (2/1/0) Wireless Sensor Networks (2/2/0) ","date":"2021-03-06","objectID":"/2021-sose/:0:2","tags":["Kurse"],"title":"2021 Sose","uri":"/2021-sose/"},{"categories":["TUD"],"content":"INF-BAS6 Theoretische Informatik Database Theory (4/2/0) Einführung in das maschinelle Übersetzen natürlicher Sprachen (2/2/0) ","date":"2021-03-06","objectID":"/2021-sose/:0:3","tags":["Kurse"],"title":"2021 Sose","uri":"/2021-sose/"},{"categories":["TUD"],"content":"INF-BAS7 Graphische Datenverarbeitung Spatiotemporal Modeling and Simulation of Biological Systems (2/2/0) Scientific Visualization (2/2/0) This is a Test And I hope it works… ","date":"2021-03-06","objectID":"/2021-sose/:0:4","tags":["Kurse"],"title":"2021 Sose","uri":"/2021-sose/"},{"categories":["Tool"],"content":"Idea Tools - IntelliJ ","date":"2021-03-05","objectID":"/idea-tools/:0:0","tags":["Tool"],"title":"Idea Tools","uri":"/idea-tools/"},{"categories":["Tool"],"content":"ShortCuts psvm $\\rarr$ public static void main(String[] args){} sout $\\rarr$ System.out.println() CTRL + y $\\rarr$ delete a row ALT + Insert $\\rarr$ add Something new CTRL + SHIFT + F12 $\\rarr$ close Side-Window ALT + $\\rarr$ || $\\larr$ change the Tab ALT + \\text{number} change Windows CTRL + p remind Parameters in Functions ","date":"2021-03-05","objectID":"/idea-tools/:1:0","tags":["Tool"],"title":"Idea Tools","uri":"/idea-tools/"},{"categories":["Learn"],"content":"Unix Programming ","date":"2021-02-23","objectID":"/unix-programming/:0:0","tags":["Unix"],"title":"Unix Programming","uri":"/unix-programming/"},{"categories":["Learn"],"content":"Bash Shortcuts Function Shortcuts Help previous Command CTRL + p previous next Command CTRL + n next move forward CTRL + f move forward move backward CTRL + b move backwoard Del CTRL + d delete Home CTRL + a move to the Begin End CTRL + e move to the End ","date":"2021-02-23","objectID":"/unix-programming/:1:0","tags":["Unix"],"title":"Unix Programming","uri":"/unix-programming/"},{"categories":["Learn"],"content":"Directories in UNIX / root Directory /bin executable Programms, like Commands /boot Kernerl and Initialization Programms /dev Devices /etc Config and Startup Files /home User’s main Directory /lib Library Files for System Programms /media media Devices like CD-ROM, USB Stick /mnt Temporate Mount-System /proc Memopry’s Map /sbin Super User executable Programms /usr /usr/bin executable Programms / Applications /usr/game ","date":"2021-02-23","objectID":"/unix-programming/:2:0","tags":["Unix"],"title":"Unix Programming","uri":"/unix-programming/"},{"categories":["Learn"],"content":"Some often-used Commands ","date":"2021-02-23","objectID":"/unix-programming/:3:0","tags":["Unix"],"title":"Unix Programming","uri":"/unix-programming/"},{"categories":["Learn"],"content":"Link ln -s \u003cSource\u003e \u003cYour_Link_Name\u003e create a soft Link. Without the -s Parameter a hard Link will be created. ","date":"2021-02-23","objectID":"/unix-programming/:3:1","tags":["Unix"],"title":"Unix Programming","uri":"/unix-programming/"},{"categories":["Learn"],"content":"Search find \u003cSearch_Directory\u003e -name \u003cFile_Name\u003e grep \u003cPattern\u003e \u003cSearch_Directory\u003e ","date":"2021-02-23","objectID":"/unix-programming/:3:2","tags":["Unix"],"title":"Unix Programming","uri":"/unix-programming/"},{"categories":["Learn"],"content":"apt Change Source edit the file /etc/apt/source.list search Software sudo apt-cache search package fix the Installation sudo apt-get -f install install relative compile Enviroment sudo apt-get build-dep package upgrade the System sudo apt-get dist-upgrade get to know Depends sudo apt-cache depends package ","date":"2021-02-23","objectID":"/unix-programming/:3:3","tags":["Unix"],"title":"Unix Programming","uri":"/unix-programming/"},{"categories":["Learn"],"content":"dpkg uninstall sudo dpkg -r --purge xxx.deb get Infos sudo dpkg -info xxx.deb show installed sudo dpkg -l ","date":"2021-02-23","objectID":"/unix-programming/:3:4","tags":["Unix"],"title":"Unix Programming","uri":"/unix-programming/"},{"categories":["Learn"],"content":"devices get Infos about Disks sudo fdisk -l mount the Disk mount \u003cDevice_Name\u003e \u003cAim-Directory\u003e unmount the Disk umount \u003cAim-Directory\u003e copy dd if=\u003cInputFile\u003e of=\u003cOutputFile\u003e [bs=\u003cFile_Size\u003e count=\u003cBlock_Size\u003e] ","date":"2021-02-23","objectID":"/unix-programming/:3:5","tags":["Unix"],"title":"Unix Programming","uri":"/unix-programming/"},{"categories":["Learn"],"content":"compressed Files tar compress tar cvf \u003c.tar File\u003e \u003cSource\u003e decompress tar xvf \u003c.tar File\u003e [-C \u003cAim-Directory\u003e] tar.gz compress tar zcvf \u003c.tar.gz File\u003e \u003cSource\u003e decompress tar zxvf \u003c.tar.gz File\u003e [-C \u003cAim-Directory\u003e] tar.bz2 compress tar jcvf \u003c.tar.bz2 File\u003e \u003cSource\u003e decompress tar -jxvf \u003c.tar.bz2 File\u003e [-C \u003cAim-Directory\u003e] rar compress rar a -r \u003c.rar File\u003e \u003cDirectory_Name\u003e decompress unrar x \u003c.rar File\u003e zip compress zip -r \u003c.zip File\u003e \u003cDirectory\u003e decompress unzip \u003c.zipFile\u003e ","date":"2021-02-23","objectID":"/unix-programming/:3:6","tags":["Unix"],"title":"Unix Programming","uri":"/unix-programming/"},{"categories":["Learn"],"content":"Process ps ps aux ps ajx ps -Lf kill kill [ -signal| -s signal ] pid ... kill -l ","date":"2021-02-23","objectID":"/unix-programming/:3:7","tags":["Unix"],"title":"Unix Programming","uri":"/unix-programming/"},{"categories":["Learn"],"content":"env env check the Environment add new $PATH: for self, export PATH=$PATH:\u003cpath\u003e in ~/.bashrc for all users, export PATH=$PATH:\u003cpath\u003e in /etc/profile ","date":"2021-02-23","objectID":"/unix-programming/:3:8","tags":["Unix"],"title":"Unix Programming","uri":"/unix-programming/"},{"categories":["Learn"],"content":"Networks Info of Netcard ifconfig shutdown Netcard sudo ifconfig eth0 down start Netcard sudo ifconfig eth0 up assign temporary IP sudo ifconfig eth0 IP Status of Network netstat transform WWW to IP nslookup ","date":"2021-02-23","objectID":"/unix-programming/:3:9","tags":["Unix"],"title":"Unix Programming","uri":"/unix-programming/"},{"categories":["Learn"],"content":"Operating System ","date":"2021-02-22","objectID":"/operating-system/:0:0","tags":["Basic of CS"],"title":"Operating System","uri":"/operating-system/"},{"categories":["Learn"],"content":"Computer Networks Foreword: References: Videos: 2021王道计算机网络 on YouTube eBook: Google Drive Link here (Chinese) Power Point: Google Drive Link here (Chinese) ","date":"2021-02-22","objectID":"/computer-networks/:0:0","tags":["Basic of CS"],"title":"Computer Networks","uri":"/computer-networks/"},{"categories":["Learn"],"content":"Ch 01. System’s Structure of Computer Networks Definition: A System that connects distributed and independent Computer Systems through Devices and Cables, therefore the Resources-Sharing and Information-Transportation are realized. It’s a Combination of connected and independent Computers. Functions: Data Communication Resources-Sharing Process distributly Improve the Reliability Balance the Load Development: APARnet -\u003e internet -\u003e Internet 3-Structures Internet: Bottom layer network -\u003e middle layer network -\u003e backbone network Some Terminologys: ISP - Internet Service Provider IXP - Internet Exchange Point PCI ( Protocol Control Information ) + SDU ( Service Data Unit ) = PDU ( Protocol Data Unit, Unit between same-level Transportation ) Standards OSI, TCP/IP RFC ( Request For Comments ): Internet Draft Proposed Standard Draft Standard Internet Standard ","date":"2021-02-22","objectID":"/computer-networks/:1:0","tags":["Basic of CS"],"title":"Computer Networks","uri":"/computer-networks/"},{"categories":["Learn"],"content":"Performance Indicators Speed: Transportation’s Speed: b/s ( $\\times10^3$ ) $\\rarr$ kb/s ( $\\times10^3$ ) $\\rarr$Mb/s ( $\\times10^3$ ) $\\rarr$Gb/s ( $\\times10^3$ ) $\\rarr$Tb/s… Difference in Storage: 1Byte = 8bit, 1KB = $2^{10}$ B = 1024B = 1024 $\\times$ 8b Band-Width: The Capacity of the Transportation of the Cable. Normally it refers to the highest Speed from one Point to another Point in Internet in Element-Time. Unit see above. Throughput: The Amount of Data that go through the Internet in Unit-Time. Unit see above. It’s limited by Band-Width. Delay: Sending-Delay: $\\text{S-Delay} = \\frac{\\text{Length of Data}}{\\text{Band-width}}$ Transportation-Delay: $\\text{T-Delay} = \\frac{\\text{Length of Band}}{\\text{Electromagnetic wave speed}}$ Pending-Delay: Wait for the Usage of I/O Route Process-Delay: Procedure with the Data Time delay bandwidth product: $\\text{Time delay bandwidth product} = \\text{Transportation-Delay} \\times \\text{Band-width}$ It talks about the Capacity of the Pipe. RTT: Delay between Sending and the Receive-Confirmation Includes Transportation-Delay * 2 + Process-Time Utilization rate Band Utilization Rate: $\\frac{\\text{Time, when Data pass}}{\\text{Time, when Data pass and not pass}}$ ","date":"2021-02-22","objectID":"/computer-networks/:1:1","tags":["Basic of CS"],"title":"Computer Networks","uri":"/computer-networks/"},{"categories":["Learn"],"content":"OSI Reference Module Structure: Physic Layer $\\rarr$ Data Link Layer $\\rarr$ Network Layer $\\rarr$ Transportation Layer ($\\rarr$ Session Layer $\\rarr$ Representation Layer) $\\rarr$ Uasge Layer Functions of Representation Layer Transform the Data Format Encrypt / Decrypt the Data Compress and Decompress the Data Functions of Session Layer Creates, manage and terminites the Session Restore the Communication through Checkpoint when something wrong goes with the Communication ( SYN ). Functions of Transportation Layer p.S. Responsible for the Communications between 2 Processes ( P2P ) Reliable / Unreliable Transportation Control of Errors Control of Flow Multiplexing and splitting Functions of Network Layer p.S. Transport the Groups from Source to the End, provide the Communication Service for the Groups to swap different Hosts. Select the Route Control of Flow Control of Errors Control of Congestion Functions of Data Link Layer Define the Begin and the End of the Frame Control of Errors ( Frame Error, Bit Error ) Control of Flow Control of Access Functions of Physic Layer Define the Features of Interface Define the Transportation Mode Define the Transportation Speed Synchronization the Bits Encode the Bits ","date":"2021-02-22","objectID":"/computer-networks/:1:2","tags":["Basic of CS"],"title":"Computer Networks","uri":"/computer-networks/"},{"categories":["Learn"],"content":"Ch 02. Physical Layer ","date":"2021-02-22","objectID":"/computer-networks/:2:0","tags":["Basic of CS"],"title":"Computer Networks","uri":"/computer-networks/"},{"categories":["Learn"],"content":"Basic Concepts Physical Layer solves how to transport Data Bit Flow on the Transportation Media on Hosts. Contains Mechanical Features, Electronic Features, Functional Features and Process Features. ","date":"2021-02-22","objectID":"/computer-networks/:2:1","tags":["Basic of CS"],"title":"Computer Networks","uri":"/computer-networks/"},{"categories":["Learn"],"content":"1. Overview Learn from online platform bilibili. ","date":"2021-02-19","objectID":"/spring/:1:0","tags":["Framework"],"title":"Spring","uri":"/spring/"},{"categories":["Learn"],"content":"1.1 Intro Based on interface21, 1.0 version published in 2014. Creator Rod Johson Aims at figuring out the complexity of the development for enterprise applications, by integrating the current techs to make them easier to use. Ingredients: SSH: Struct2 + Spring + Hibernate SSM: SpringMVC + Spring + Mybatis ","date":"2021-02-19","objectID":"/spring/:1:1","tags":["Framework"],"title":"Spring","uri":"/spring/"},{"categories":["Learn"],"content":"1.2 Advantages Open source, free framework Light, uninvisioned framework IOC(Inversion Of Control), AOP(Aspect Oriented Programming) Supports the process of events and integration of frameworks ","date":"2021-02-19","objectID":"/spring/:1:2","tags":["Framework"],"title":"Spring","uri":"/spring/"},{"categories":["Learn"],"content":"1.3 Composition Spring Boot Scaffload for quick development Quick single micro servive development Coordination is more important than configuration Spring Cloud Based on Spring Boot \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.3.6\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.3.6\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-02-19","objectID":"/spring/:1:3","tags":["Framework"],"title":"Spring","uri":"/spring/"},{"categories":["Learn"],"content":"2. IoC theory A method that through describtion and with the help of the third parts to get or new the specific objects. IoC container implements the Interval of Control, the method is DI (Dependicy Injection). Before, programmers create objects, they control which objects to be created. By adding a Setter(), users have the right to create objects -\u003e decoupling For example, User.java and Service.java. Before decoupling: public interface UserInter{ void getUser(); } public class User implements UserInter{ public void getUser(){ System.out.println(\"Info from User\"); } } public class UserSQL implements UserInter{ public void getUser(){ System.out.println(\"Info from UserSQL\"); } } public class UserNginx implements UserInter{ public void getUser(){ System.out.println(\"Info from UserNginx\"); } } public class Server{ private User user = new User(); public void getUser(){ user.getUser(); } // In this main method, if we want to get other informations from user // we need to create other classes (i.e. UserSQL, UserNginx, etc.) // which is not convenient // Or, we create o } public class Test{ Server server = new Server(); server.getUser(); } After decoupling: public class Server{ private User user; // Set injection public void setUser(Uset user){ this.user = user; } public void getUser(){ user.getUser(); } } public class Test{ Server server = new Server(); server.setUser(new UserSQL()); // After decoupling, we just need to change line // in the backets. We can new UserSQL, User, UserNginx, etc. server.getUser(); } ","date":"2021-02-19","objectID":"/spring/:2:0","tags":["Framework"],"title":"Spring","uri":"/spring/"},{"categories":["Learn"],"content":"3. Hello Spring ","date":"2021-02-19","objectID":"/spring/:3:0","tags":["Framework"],"title":"Spring","uri":"/spring/"},{"categories":["Learn"],"content":"4. How does IoC create objects Use methods without Parameters to create objects by default 3 ways to create objects with parameters: With the index of the initialization method \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg index=\"0\" value=\"Learn Spring\"/\u003e \u003c/bean\u003e With the type of parameters of initialization method ( not recommanded ) \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg type=\"java.lang.String\" value=\"Learn Spring\"/\u003e \u003c/bean\u003e With the name of parameters of initializtion method ( recommand ) \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg name=\"name\" value=\"Learn Spring\"/\u003e \u003c/bean\u003e When loading cofigure file (xxx.xml), the objects in the container are initialized ","date":"2021-02-19","objectID":"/spring/:4:0","tags":["Framework"],"title":"Spring","uri":"/spring/"},{"categories":["Learn"],"content":"5. Configuration of Spring ","date":"2021-02-19","objectID":"/spring/:5:0","tags":["Framework"],"title":"Spring","uri":"/spring/"},{"categories":["Learn"],"content":"5.1 alias \u003calias name=\"user\" alias=\"user2\"/\u003e - single alias We can through the alias get the object. ","date":"2021-02-19","objectID":"/spring/:5:1","tags":["Framework"],"title":"Spring","uri":"/spring/"},{"categories":["Learn"],"content":"5.2 configure bean id class name identifier, object-name package + class alias \u003cbean id=\"user\" class=\"com.kuang.pojo.User\" name=\"user3, user3, ...\"\u003e multi-alias in \u003cbean\u003e, can be seperated with space, ,, ; ","date":"2021-02-19","objectID":"/spring/:5:2","tags":["Framework"],"title":"Spring","uri":"/spring/"},{"categories":["Learn"],"content":"5.3 import Used for teamwork, import and merge multi-configure files \u003cimport resource=\"other_beans.xml\"/\u003e ","date":"2021-02-19","objectID":"/spring/:5:3","tags":["Framework"],"title":"Spring","uri":"/spring/"},{"categories":["Learn"],"content":"6. Dependency Injection (DI) Constructor injection, see #4 Set What is DI - Set injection Dependency: The creation of the objects in bean depend on container All attributes of the objects in bean are injected by container An example \u003c!--beans.xml--\u003e \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"student\" class=\"com.kuang.pojo.Student\"\u003e \u003cproperty name=\"name\" value=\"zhangsan\"/\u003e \u003c/bean\u003e \u003c/beans\u003e // Student.java public class Student { private String name; private Address address; private String[] books; private List\u003cString\u003e hobbys; private Map\u003cString, String\u003e card; private Set\u003cString\u003e games; private Properties info; private String wife; } // Address.java public class Address { private String address; public void setAddr(String address) { this.address = address; } @Override public String toString() { return \"Address{\" + \"address='\" + address + '\\'' + '}'; } public String getAddr() { return address; } } // Test Class public class MyTest { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student student = (Student) context.getBean(\"student\"); System.out.println(student.toString()); } } \u003c!-- complete --\u003e \u003cbean id=\"address\" class=\"com.kuang.pojo.Address\"\u003e \u003cproperty name=\"addr\" value=\"Xian\"/\u003e \u003c/bean\u003e \u003cbean id=\"student\" class=\"com.kuang.pojo.Student\"\u003e \u003cproperty name=\"name\" value=\"zhangsan\"/\u003e \u003c!-- reference here --\u003e \u003cproperty name=\"address\" ref=\"address\"/\u003e \u003c!-- Array --\u003e \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e《黑暗森林》\u003c/value\u003e \u003cvalue\u003e《死神永生》\u003c/value\u003e \u003cvalue\u003e《人生海海》\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e \u003c!-- List --\u003e \u003cproperty name=\"hobbys\"\u003e \u003clist\u003e \u003cvalue\u003esing\u003c/value\u003e \u003cvalue\u003ecode\u003c/value\u003e \u003cvalue\u003emusic\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003c!-- Map --\u003e \u003cproperty name=\"card\"\u003e \u003cmap\u003e \u003centry key=\"tianwang\" value=\"dihu\"/\u003e \u003centry key=\"ID\" value=\"1234567890\"/\u003e \u003c/map\u003e \u003c/property\u003e \u003c!-- Set --\u003e \u003cproperty name=\"games\"\u003e \u003cset\u003e \u003cvalue\u003emario\u003c/value\u003e \u003cvalue\u003elol\u003c/value\u003e \u003cvalue\u003eCS go\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e \u003cproperty name=\"wife\"\u003e \u003cnull/\u003e \u003c/property\u003e \u003c!-- Properties --\u003e \u003cproperty name=\"info\"\u003e \u003cprops\u003e \u003cprop key=\"姓名\"\u003enoone\u003c/prop\u003e \u003cprop key=\"学号\"\u003e10294658\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e Reference, click here ","date":"2021-02-19","objectID":"/spring/:6:0","tags":["Framework"],"title":"Spring","uri":"/spring/"},{"categories":["Learn"],"content":"Autowire of bean A method from bean, that satisfies the dependencies of bean Search in context, and load the properties for bean automatically ","date":"2021-02-19","objectID":"/spring/:7:0","tags":["Framework"],"title":"Spring","uri":"/spring/"},{"categories":["Learn"],"content":"3 ways to load xml java hidden autowire autowire=\"byName\": Ensure that beanid is unique, and same as the set methods of the injected property. sutowire=\"byType\": Ensure that the class of bean is unique, and same as the class of the injected property. Example public class Person{ private Cat cat; private Dog dog; private String name; //etters and setters... // Constructors with/without partameters... } \u003cbean id=\"dog\" class=\"com.kuang.pojo.Dog\"\u003e \u003cbean id=\"cat\" class=\"com.kuang.pojo.Cat\"\u003e \u003cbean id=\"person\" class=\"com.kuang.pojo.Person\" autowire=\"byName\"\u003e \u003cbean class=\"com.kuang.pojo.Dog\"\u003e \u003cbean class=\"com.kuang.pojo.Cat\"\u003e \u003cbean id=\"person\" class=\"com.kuang.pojo.Person\" autowire=\"byType\"\u003e ","date":"2021-02-19","objectID":"/spring/:7:1","tags":["Framework"],"title":"Spring","uri":"/spring/"},{"categories":["Learn"],"content":"Java Learning ( Data Structures, mostly ) … And the greatest reason I learn it, is that I LOVE COFFEE ☕ its DS are soooooooooooo smoooooooth. ","date":"2021-02-03","objectID":"/java-learning/:0:0","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"01. Basic Usage in Java ","date":"2021-02-03","objectID":"/java-learning/:1:0","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"Way to write A .java File can be compiled through javac into .class File. .java File is called Source Code, after Compling it can be deleted. In every .java File can multiple Class be written. In every Class can multiple Methods be written. After Compiling, execute java class_name in Terminal to run Functions in a specific class. A .java File can contain multipule class, but only 1 public class. Besides, the name of the public class must be same as the .java file. // C.java class A{ public static void main(String[] args){ //Codes here } } class B{ public static void main(String[] args){ // Codes here } } public class C{ public static void main(String[] args){ // Codes here } } In every class, there is only 1 main Method. The way to write it is always this: public class C{ public static void main(String[] args){ // Codes here // Attribute(s) // Method(s) } } At the end, like old Style, say “Hello world!\":) // HelloWorld.java public class HelloWorld { public static void main(String[] args){ System.out.println(\"Hello World!\"); } } ","date":"2021-02-03","objectID":"/java-learning/:1:1","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"02. Transformation of DataTypes in Java Except boolean, other DataType can be transformed into another. Low Capacity Data to High Capacity Data is called Auto Transformation. Capacity from low to high: byte \u003c short / char \u003c int \u003c long \u003c float \u003c double High Capacity Data to Low Capacity Data is called Forced Transformation. This can cause The Loss of Accurity. Miss-Calculation among byte, short, char, they transform into int firstly. Mix-Calculation among mix-DataTypes, they transform into the DataType with largest Capacity among them firstly. ","date":"2021-02-03","objectID":"/java-learning/:2:0","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"03. Methods in Class ","date":"2021-02-03","objectID":"/java-learning/:3:0","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"What is Methods Methods are a Piece of Code, they can handle with specific Problems and are written in Class ( Method in Method is not possible! ), and the Sequence of Methods have no Influence on Code. ","date":"2021-02-03","objectID":"/java-learning/:3:1","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"Format [Modifier List] return-Type Method-Name(Parameters){ Codes that handle with Problems; } ","date":"2021-02-03","objectID":"/java-learning/:3:2","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"static or NOT? Methods without static can be used only through an Object. They are called as Instance Methods. if a Move needs Object to take part in, DONOT use static. Methods with static donot need Object to take part in. To access, Class_Name.Method() class Method{ public static void doSome(){ // Codes } public void doOther(){ // Codes } public static void main(String[] args){ Student s = new Student(); Method.doSome(); // doSome(); Method m = new Method(); m.doOther(); } } ","date":"2021-02-03","objectID":"/java-learning/:3:3","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"Usage You can define Methods, but you must not use them. In Class, type: Class-Name.Method-Name(Parameters) If static is in [Modifier List](Reference here) or the Methods are with the Calling-Code in the same Class, Class-Name can be ignored. Methods in other Class, must be Class-Name.Method-Name(Parameters). ","date":"2021-02-03","objectID":"/java-learning/:3:4","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"Overload: Methods with same Names and finish similar Functions. See Code below: public class OverloadTest(){ public static void main(String[] args){ int result1 = sumInt(1,2); System.out.println(result1); double result2 = sumDouble(1.0, 2.0); System.out.println(result2); long result3 = sunLong(1L, 2L); System.out.println(result3); } public static int sumInt(int a, int b){ return a + b; } public static double sumDouble(double a, double b){ return a + b; } public static long sumLong(long a, long b){ return a + b; } } Though Functions sumInt(), sumDouble(), sumLong() are different, but they are similar. Overload see below: public class OverloadTest(){ public static void main(String[] args){ int result1 = mySum(1,2); System.out.println(result1); double result2 = mySum(1.0, 2.0); System.out.println(result2); long result3 = mySum(1L, 2L); System.out.println(result3); } public static int mySum(int a, int b){ return a + b; } public static int mySum(double a, double b){ return a + b; } public static int mySum(long a, long b){ return a + b; } } Code above will automatically select which mySum will be used. When will Overload occur, it goes with Parameters only… Case Examples in same Class Basic 1 with the same Method Name Basic 2 Parameters in different amount public static void m1(); public static void m1(int a) Parameters in different Sequence public static void m2(int a, double b); public static void m2(double a, int b) Paramaters in different Types public static void m3(int a); public static void m3(double a) ","date":"2021-02-03","objectID":"/java-learning/:3:5","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"04. JVM ","date":"2021-02-03","objectID":"/java-learning/:4:0","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"3 primary Memory Spaces in JVM Ref here Method Areas: Codes and static Variables ( Instance Variables ) Heap: storage Instance Variables. This Memory are handeled by Trash cycle Programm. Stacks: when Methods are used, assign Room here, Stack-push. when Methods are finished, Stack-pop. on Running-Phase local Variables are storaged here. This Memory are mostly used. ","date":"2021-02-03","objectID":"/java-learning/:4:1","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"where are the Variables? Variables / Attributes beyond Methods in Class are called Member Variables ( It’s accessble only through Object ). class Student{ //Member Variables below int stu_No; String name; int age; String address; ... // Member Variables without `static` are called Instance Variables; // instead, Member Variables with `static` are called static Variables. } public class myClass{ public static void main(String[] args){ int i = 10; Student s = new Student(); // s maps the Address of the Instance, // Instance / Object is storaged in Heap in JVM // s and i are storaged in Stack in JVM // s have Member Variables. } } In the Code above, i and s called local Variable ( in Stack ), s' Attributes like stu_No, age, etc. are called Instant Variables ( in Heap ). Member Variables contain static Variables and Instance Variables. Modifier Function public accessible anywhere static accessible without Object protacted accesible in the same Package, and Subclass None accessible in the same Package ","date":"2021-02-03","objectID":"/java-learning/:4:2","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"05. Object-oriented ","date":"2021-02-03","objectID":"/java-learning/:5:0","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"3 Features Encapsulation ( Attributions ) simplify, offer simple Interfaces for Users. ( i.e, Camera ) after Encapsulation there is Object after Encapsulation the Programms becomes resuable improve the Security private Attributions $\\rarr$ write Interfaces ( set and get. These 2 Methods have no Modifier static) class Student{ private String name; private int age; private String addr; public void setName(String myName){ name = myName; // Code that determins the Legality } public String getName(){ return name; } } Inheritance Ancestor: java.lang.Object [Modifiers] class subclass extands superclass{} Basic: Reusablility of Codes; Advanced: Base Stone of the Overload and the Polymorphism superclass and subclass private, Constructors are not inheritance. Polymorphism upcasting: subclass $\\rarr$ superclass ( automatic ) downcasting: superclass $\\rarr$ subclass ( forced ) when specific Methods are only in Subclass There must be extend-Relationship by upcasting and downcasting 大家都知道花木兰替父从军的例子，花木兰替父亲花弧从军。那么这时候花木兰是子类，花弧是父类。花弧有自己的成员属性年龄，姓名，性别。花木兰也有这些属性，但是很明显二者的属性完全不一样。花弧有自己的非静态成员方法‘骑马杀敌’，同样花木兰也遗传了父亲一样的方法‘骑马杀敌’。花弧还有一个静态方法‘自我介绍’，每个人都可以问花弧姓甚名谁。同时花木兰还有一个自己特有的非静态成员方法‘涂脂抹粉’。但是，现在花木兰替父从军，女扮男装。这时候相当于父类的引用（花弧这个名字）指向了子类对象（花木兰这个人），那么在其他类（其他的人）中访问子类对象（花木兰这个人）的成员属性（姓名，年龄，性别）时，其实看到的都是花木兰她父亲的名字（花弧）、年龄（60岁）、性别（男）。当访问子类对象（花木兰这个人）的非静态成员方法（骑马打仗）时，其实都是看到花木兰自己运用十八般武艺在骑马打仗。当访问花木兰的静态方法时（自我介绍），花木兰自己都是用她父亲的名字信息在向别人作自我介绍。并且这时候花木兰不能使用自己特有的成员方法‘涂脂抹粉’。 那么终于一将功成万骨枯，打仗旗开得胜了，花木兰告别了战争生活。有一天，遇到了自己心爱的男人，这时候爱情的力量将父类对象的引用（花弧这个名字）强制转换为子类对象本来的引用（花木兰这个名字），那么花木兰又从新成为了她自己，这时候她完全是她自己了。名字是花木兰，年龄是28，性别是女，打仗依然那样生猛女汉子，自我介绍则堂堂正正地告诉别人我叫花木兰。OMG！终于，终于可以使用自己特有的成员方法‘涂脂抹粉’了。从此，花木兰完全回到了替父从军前的那个花木兰了。并且和自己心爱的男人幸福的过完了一生。 public class Animal{ public void move(){ System.out.println(\"Animal Moving!\"); } public static void main(String[] args){ Animal a = new Bird(); a.move(); //Bird to Animal, upcasting // a.move() -\u003e Bird Flying! // a.sing() -\u003e CANNOT compile. In Class Animal there's no Method called \"sing()\" // In other Word: Compile check a's Class, Animal. But Animal cannot sing. // Run: run Methods in Bird. Because we have a Bird() Object \"newed\". // when we want Animal a to sing, we can transform its' DataType Bird b = (Bird) a;//Animal to Bird, downcasting b.move(); //Bird Fying! b.sing(); // Bird Singing! Cat c = (Cat) a; } } class Bird extends Animal{ public void move(){ System.out.println(\"Bird Flying!\"); } public void sing(){ System.out.println(\"Bird Singing!\"); } } class Cat extends Animal{ public void move(){ System.out.println(\"Cat Jumoing!\"); } public void catchMouse(){ System.out.println(\"Cat catches Mouse!\"); } } java.lang.ClassCastException It happens in downcasting. /* Codes below can compile. */ public class Animal{ public void move(){ System.out.println(\"Animal Moving!\"); } public static void main(String[] args){ Animal a = new Bird(); // We created a Bird Object, store its' Address in a with Animal. Cat c = (Cat) a; // Bird and Cat have no Inheritance Relationship. It cannot run. // But in Compile, while a's Type is Animal, Animal and Cat have Inheritance Relationship, compile works. } } how to avoid java.lang.ClassCastException $\\rarr$ instanceof Reference instanceof Data-Type returns boolean public class Animal{ public void move(){ System.out.println(\"Animal Moving!\"); } public static void main(String[] args){ Animal a = new Bird(); // We created a Bird Object, store its' Address in a with Animal. // a is an Instance of Bird, but Reference is Animal. if(a instanceof Cat){ Cat c = (Cat) a; c.catchMouse(); } else if(a instanceof Bird){ Bird b = (Bird) a; b.sing(); } } } classic Polymorphism Codes public class Test{ public static void main(String[] args){ Master m = new Master(); // Parentclass oriented Programming Pet p = new Cat(); m.feed(p); // Cat eating } } class Master{ public void feed(Pet p){ p.eat(); } } class Pet{ public void eat(){ System.out.println(\"Pet eating\"); } } class Cat extends Pet{ public void eat(){ System.out.println(\"Cat eating\"); } } class Dog extends P","date":"2021-02-03","objectID":"/java-learning/:5:1","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"In the Life Circle: Object Oriented Analysis (OOA) Object Oriented Design (OOD) Object Oriented Programming (OOP) ","date":"2021-02-03","objectID":"/java-learning/:5:2","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"Class / Object ( Instance ) in Java Class: A Template, a Concept, doesn’t exist in the real World, an abstract Result after Thought. describes mostly Status (Attributes) and Actions (Methods). Object: Individual in the real World. Inner Class: Class in Class static, instance, local inner Class class Test{ static class Inner1{ } // static Class Inner1 class Inner2{ } // Instance Class Inner2 public void doSome(){ int i = 100; class Inner3{ }// local Class Inner3, accessible only in doSome() } } ","date":"2021-02-03","objectID":"/java-learning/:5:3","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"Constructor Differences between Methods and Constructor ( has return-Type or not ) [Modifier List] Constructor-Name(parameters){ //Codes } [Modifier List] return-Type Method-Name(Parameters){ //Codes } Constructor-Name must be same as Class-Name. ","date":"2021-02-03","objectID":"/java-learning/:5:4","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"this Key Word Appears in Constructor and Methods, cannot appear in static Method this points at the Object itself. It’s saved in Heap. this appears in Instance Methods ( Methods without static ) this can also appear in Constructors, using other Constructors at the meanwhile. public class Customer{ String name; public Customer(){ // this.name = \"NULL\"; this(name); } public Customer(String name){ this.name = name; } public void shopping(){ System.out.println(this.name + \"is shopping!\"); } } ","date":"2021-02-03","objectID":"/java-learning/:5:5","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"static an Example: public class Customer { public static void shopping() { System.out.println(\"In shopping!\"); } public void running() { System.out.println(\"On running!\"); } public static void main(String[] args){ Customer c1 = new Customer(); // Method \"running()\" is only through an Object accessible. c1.running(); // The following Codes output without Nullpointer Error. // There's Warning. static Methods are accessible through object, too. // BUT, Advice is, use it through \"Class.static_Method()\". c1 = null; c1.shopping(); } } when static Variables? Same Attribute(s) in Objects static Variables are storaged during the Load of Class in “Method Area” static Variables have Nothing to do with Objects. static Code Block will be executed during the Load of Class from up to down and only once. static Code Block can be used to record when the Class are loaded. ( Log ) p.S. Instance Code Block can be used to record when the Object are created. public class Chinese{ private String name; private String id; // the Variable \"country\" here are same: China. // private String country; // So we write it in this Way static String country = \"China\"; // By writing in this way the Variable \"country\" is saved in \"Method Area\" instead of in \"Heap\" // It's accessible by: // zhangsan.country; // Chinese.country; } In static there’s no this. It cannot visit Instance Variables and Instance Methods directly ( must through an Object ). ","date":"2021-02-03","objectID":"/java-learning/:5:6","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"Override when Override? Methods in Superclass cannot feed the Need of Subclass Override Methods have same Modifier, returnType and Parameters The Access Right must be same or higher The Number of Errors must be same or less Deals with only Methods ( except static Methods ) Override the Methods in the closet Superclass public class Animal{ protected void move(){ System.out.println(\"Moving\"); } } public class Bird extends Animal{ public void move(){ System.out.println(\"Flying\"); } } ","date":"2021-02-03","objectID":"/java-learning/:5:7","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"final final Class cannot be inheritaged final Methods cannot be override final Variables cannot be changed after Value given final Variable must be Value given manually final static Variable is called Constant ( e.g., final static double PI = 3.1415926, Constant should be written in UPPERCASE ) public class Test{ final int age = 24; // Variable age here must be a Value given. // And it cannot be given Value again. } public class Test{ final int age; public Test(){ this.age = 24; } // Variable age here must be a Value given. // And it cannot be given Value again. } public class Test{ public static void main(String[] args){ User u = new User(100); // Variable u above watiting to be handeled by Trash Recycling. Usre u = new User(200); } } class User{ int credit; public User(int credit){ this.credit = credit; } } public class Test{ public static void main(String[] args){ final User u = new User(100); // Variable u above CANNOT be handeled by Trash Recycling. // And we are noot allowed to new a new User Object u.credit = 10000; // But Variables in u can be modified. } } class User{ int credit; public User(int credit){ this.credit = credit; } } ","date":"2021-02-03","objectID":"/java-learning/:5:8","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"super Father first, then Child. public class A{ public A(){ System.out.println(\"Constructor without Parameters in A!\"); } public static void main(String[] args) { A a = new A(); System.out.println(\"------------------------------------\"); B b = new B(); } } class B extends A{ public B(){ System.out.println(\"Constructor without Parameters in B!\"); } } // output Constructor without Parameters in A! ------------------------------------ Constructor without Parameters in A! Constructor without Parameters in B! public class A { public A() { System.out.println(\"Constructor without Parameters in A!\"); // -\u003e 1. Father First } public static void main(String[] args) { A a = new A(); System.out.println(\"------------------------------------\"); B b = new B(); b.getName(); } } class B extends A { private String name; public B() { this(\"zhangsan\"); // -\u003e 2. Constructor with String System.out.println(\"Constructor without Parameters in B!\"); // -\u003e 3. syso System.out.println(); } public B(String name) { this.name = name; System.out.println(\"Constructor with String in B!\"); // -\u003e 2. Constructor with String } public void getName() { System.out.println(this.name); } } // output Constructor without Parameters in A! ------------------------------------ Constructor without Parameters in A! // -\u003e 1. Father First Constructor with String in B! // -\u003e 2. Constructor with String Constructor without Parameters in B! // -\u003e 3. syso zhangsan ","date":"2021-02-03","objectID":"/java-learning/:5:9","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"abstract class Definition Class and Class have commen Features. These Features become abstract class. abstract class cannot have Instance. But it can have Constructors -\u003e used by Subclass abstract class are used to be inherited. the Subclass of abstract class can also be abstract class. final and abstract cannot be together. Howto [modifier] abstract class class_Name{ //Codes } abstract Methods -\u003e ( half abstract ) public abstract void doSome(); // No Function Body ( no '{}' ), end with ; abstract class may not have abstract Methods, but abstract Methods must show up in abstract class. when there’s a Subclass ( Non-abstract ), it must rewrite the abstract Mehtods in its' Parent Class. public abstract Animal{ public abstract void move(); } class Bird extends Animal{ public void move(){ } // if there's no rewirte of this Method, compile error. } ","date":"2021-02-03","objectID":"/java-learning/:5:10","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"interface -\u003e ( total abstract ) Howto [Modifier] interface interface_Name{ //Codes } interface supports ( multy ) Inheritage interface has only 2 Parts: ( public static final ) Const and ( public abstract ) Methods. Everthing in interface are public. public abstract before Methods can be ignored. interface A{ } interface B{ } interface myMath extends A, B{ double PI = 3.1415926; //public static final double PI = 3.1415926; int sum(int a, int b); //public abstract int sum(int a, int b); } when an unabstract class implements an interface, every ( public abstract ) Methods in interface must be rewritten. [Modifier] must have public. public class interface_Test { public static void main(String[] args) { myMath m1 = new myMathImpl(); System.out.println(m1.sub(2,1)); System.out.println(m1.sum(3,4)); } } interface myMath{ double PI = 3.1415926; int sum(int a, int b); int sub(int a, int b); } class myMathImpl implements myMath{ public int sum(int a, int b){ return a + b; } public int sub(int a, int b){ return a - b; } } one class can implement multiple interface. interface can transform into other interface without Inheritage. different from class, upcasting and downcasting in class must have Inheritage. public class multi_implements { public static void main(String[] args) { A a = new D(); B b = new D(); C c = new D(); B b1 = (B) a; //interface can transform into other interface // better way to write: if(a instanceof B) B b1 = (B) a; b1.m2(); } } interface A{ void m1(); } interface B{ void m2(); } interface C{ void m3(); } class D implements A, B, C{ @Override public void m1(){ System.out.println(\"m1...\"); } @Override public void m2() { System.out.println(\"m2...\"); } @Override public void m3() { System.out.println(\"m3...\"); } } This completes, that in Java class can extend only one single class. when implements and extends exist together: class_Name extends parent_Class_Name implements interface_Name public class test04 { public static void main(String[] args) { flyable f = new Cat(); f.Fly(); flyable f1 = new Pig(); f1.Fly(); //Polymorphism } } interface flyable{ void Fly(); } class Animal{ } class Cat extends Animal implements flyable{ public void Fly(){ System.out.println(\"Cat! Fly me to the Moon!\"); } } class Pig extends Animal implements flyable{ public void Fly(){ System.out.println(\"Flying Pig! FFFFFFFF!\"); } } // output // Cat! Fly me to the Moon! // Flying Pig! FFFFFFFF! ","date":"2021-02-03","objectID":"/java-learning/:5:11","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"In a Word.. is a -\u003e extends class Cat extends Animal{ //Codes } has a -\u003e Attributes class Cat extends Animal{ private boolean Tail; } is like a -\u003e implements interface Menu{ void Steak(); } class Cooker implements Menu{ public void Steak(){ System.out.println(\"cooking Steak...\"); } } ","date":"2021-02-03","objectID":"/java-learning/:5:12","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"An Example of interface // Menu.java public interface Menu { void Steak(); void Pasta(); } // Customer.java public class Customer { private Menu foodmenu; public Customer() { } public Customer(Menu foodmenu) { this.foodmenu = foodmenu; } public Menu getFoodmenu() { return this.foodmenu; } public void order() { foodmenu.Pasta(); foodmenu.Steak(); } } // AmericanCooker.java public class AmericanCooker implements Menu { @Override public void Pasta() { System.out.println(\"Pasta with Pfeffer Minz!\"); } @Override public void Steak() { System.out.println(\"Steak with Butter!\"); } } // ChineseCooker.java public class ChineseCooker implements Menu{ @Override public void Steak() { System.out.println(\"Steak with chinese Oil!\"); } @Override public void Pasta() { System.out.println(\"Pasta with chinese Tomatoes!\"); } } // menu_Test.java public class menu_Test { public static void main(String[] args) { Menu cooker1 = new ChineseCooker(); Customer customer = new Customer(cooker1); customer.order(); } } ","date":"2021-02-03","objectID":"/java-learning/:5:13","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"Differences between interface and abstract class interface abstract class total abstract half abstract without Constructor with Constructor multiple Inheritance single Inheritance only Const and abstract Methods a class can implements multiple interface, but only 1 class to inheritage ","date":"2021-02-03","objectID":"/java-learning/:5:14","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"06. package and import package \u003cPackage_Name\u003e; Template of Package Name Reverse of the Company's Host + Project_Name + Module_Name + Function_Name Write in Lowercase ( i.e., package org.apache.tomcat.core' ) a package maps a Directory after using package, Class has changed into package_Name + Class_Name how to compile javac -d . XXX.java the Command above creates multiple Directories, that splits package_Name into Direstories. how to run .class run Command java package_Name.XXX under the same Directory of XXX.java File. that is to say, the class_Name of xxx.java becomes package_Name.XXX ","date":"2021-02-03","objectID":"/java-learning/:6:0","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"an Example // HelloWorld.java package self.study; public class HelloWorld{ public static void main(String[] args){ System.out.println(\"package test!\"); } } // Test.java package self; public class Test{ public static void main(String[] args){ self.study.HelloWorld hw = new self.study.HelloWorld(); System.out.println(\"In Test!\"); } } HelloWorld.java and Test.java locate at the same Dirtectory. HelloWorld.class locates in ./self/study, Test.class locates in ./self. when we new an Object of HelloWorld.class, we have to write it in self.study.HelloWorld hw = new self.study.HelloWorld() without import. with import, we rewrite Test.java, and import the class we need. // Test.java package self; import self.study.HelloWorld public class Test{ public static void main(String[] args){ HelloWorld hw = new HelloWorld(); System.out.println(\"In Test!\"); } } ","date":"2021-02-03","objectID":"/java-learning/:6:1","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"when import class A and class B locate in same package, we donot need to import class A and class B locate in different package, we need to import import locates under package \u003cpackage_Name\u003e; above [Modifiers] class \u003cclass_Name\u003e an often-used Case: import java.util.Scanner Here java.util is a package_Name. java.lang package will be automatically imported. ","date":"2021-02-03","objectID":"/java-learning/:6:2","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"07. Access Control ( [Modifiers] ) private protected public - same Class same Class, same Package and Subclass Anywhere same Class and Package public \u003e protected \u003e - \u003e private ","date":"2021-02-03","objectID":"/java-learning/:7:0","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"08. typical Methods in Class Object toString() It’s recommanded, that toString() should be rewritten. when a Ref / Instance is output, toString() will be aumomatically used. class Customer{ private String Name; private int Age; private String IDnumber; public Customer(){ } public Customer(String Name, int Age, String IDnumber){ this.Name = Name; this.Age = Age; this.IDnumber = IDnumber; } public String toString(){ return \"Name: \" + this.Name + \" Age: \" + this.Name.toString() + \" IDnumber: \" + this.IDnumber; } } equals() public boolean equals(Object obj){ return this == obj; } to decide, wether 2 Objects are same - comparing their Memory Addresses. ( fast can be simplified as == ) It’s recommanded, that equals() should be rewritten. class Customer{ private String Name; private String IDnumber; public static boolean equals(Object obj){ if(obj == null) return false; Customer objtemp = (Customer) obj; return objtemp.Name == this.Name \u0026\u0026 objtemp.IDnumber == this.IDnumber; } } // when 2 Customer Objects with same Name and IDnumber, they should be same. // if we dont't rewrite equals(), their Memory Addresses are not same. hashCode() public native int hashCode(); This Method transforms the Memory Address into an unique HashCode. ","date":"2021-02-03","objectID":"/java-learning/:8:0","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"08. Data Structure ","date":"2021-02-03","objectID":"/java-learning/:9:0","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"Math \u0026 Nums Short, Integer, Long, Float, Double, Boolean, Character, Byte. Methods of Classes above: click here P.S. Nums.toString(): transfer a Number to String ","date":"2021-02-03","objectID":"/java-learning/:9:1","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"String ( java.lang.String ) java.lang.StringBuffer \u0026 java.lang.StringBuilder Source Code of StringBuffer SourceCode of StringBuilder StringBuffer is modified by synchronized, it’s multy-Thread safe. StringBuffer sb1 = new StringBuffer(); // on Initialization, we should give a relative great Capacity sb1.append(\"abc\"); // Method append() to add Elements StringBuilder sb2 = new StringBuilder(); sb2.append(\"abc\"); Mostly used Methods Name Function byte[] getBytes() transform Characters in String into a Byte-Array char[] toCharArray() transfer the String into an Character-Array char charAt(int index) returns the Character at the Index. int length() returns the Length of the String int parseInt() transfer the String into an Integer int hashCode() returns the HashCode of the String int compareTo(String s) returns 0 if 2 Strings are same, returns negative if String \u003c s, else positive int indexOf(SubString s) returns the index of the Substring when it appears in String for the first time int lastIndexOf(SubString s) returns the index of the Substring when it appears in String for the last time int indexOf(char ch(,int fromIndex)) returns the Index of the Character ch the first time it appears( after the fromIndex) boolean isEmpty() if the String is empty boolean startsWith(CharSequence s) judge if String starts with the CharSequence s boolean contains(CharSequence s) judge if String contains the CharSequence s boolean endsWith(CharSequence s) judge if String ends with the CharSequence s boolean equalsIgnoreCase(String s) judge if 2 Strings are same, ignore Lower- or Uppercase String[] split(String regex) split the String by regex String trim() delete the space before / after the String static String valueOf() transform Something, which doesn’t belong to String, into String (if toString() isn’t rewritten in Object, then Memory Address ) String toLowerCase() transform the String into Lowercase String toUpperCase() transform the String into Uppercase String replace(char oldChar, char newChar) replace oldChar by newChar String subString(int startIndex(, int endIndex)) returns the subString that starts from the startIndex ( till the endIndex ) of the String [startIndex, endIndex) Other Methods of String: click here The DataType above is often used to initialize a DataStructure ( See below ). length is an Attribute of Array but a Method of String How String is storaged String is storaged in the String-Const-Pool of the Method Area String s1 = \"xyz\"; String s2 = \"abcd\" + \"xs\"; /* we get s1 and s2 in Stack, which point at \"xyz\", \"abcdxs\" in the String-Const-Pool of the Method Area String-Const-Pool has \"xyz\", \"abcd\", \"xs\" */ String s3 = new String(\"ab\"); /* we get s3 in Stack, a String Object in Heap, which points at \"xy\" in the String-Const-Pool of the Method Area */ Const and Object String s1 = \"abs\"; String s2 = \"abs\"; // s1 = s2 String s3 = new String(\"xyz\"); String s4 = new String(\"xyz\"); // s3 != s4 // BUT, s3.equals(s4) = true // So use equals() Method, instead of == ","date":"2021-02-03","objectID":"/java-learning/:9:2","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"Queue \u0026 Stack \u0026 Bag Initialization Queue Initialization Queue\u003cDataType\u003e queue_name = new Queue\u003cDataType\u003e() int size() returns the size of the Queue boolean isEmpty() judge if the Queue is empty enqueue(DataType Item) enqueue an Item into a Queue DataType dequeue() dequeue the first-in Item Options Stack Initialization Stack\u003cDataType\u003e stack_name = new Stack\u003cDataType\u003e() int size() returns the size of the Stack boolean isEmpty() judge if the Stack is empty push(DataType item) push a new element into a Stack DataType pop() returns the last-in Item Options Bag Initialization Bag\u003cDataType\u003e bag_name = new Bag\u003cDataType\u003e() int size() returns the size of the Bag add(DataType Item) add an Item into the Bag ","date":"2021-02-03","objectID":"/java-learning/:9:3","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"Arrays -\u003e java.util.Arrays \u003cDataType\u003e[] \u003cArray_Name\u003e = new \u003cDataType\u003e[\u003cArray_Size\u003e]; ( dynamic Initialization, for( ; ; ) Array[i] = ...; ) Object[] \u003cArray_Name\u003e can storage any Ref-Type \u003cDataType\u003e[] \u003cArray_Name\u003e = {\u003cDataType\u003eobj1, ...}; ( static Initialization ) storaged in Heap-Memory ( Object ) length Attribute is contained in every Array the Elements in Array are storaged continuely in Space ( Memory Address, one by one ) the Address of the first Element is the Memory Address of the whole Array how to use Array as Parameter in a Method Method_Name(Array_Name) Method_Name(new \u003cDataType\u003e[] {\u003cDataType\u003eobj1, ...}) Elements in String[] args in public static void main(String[] args) are prepared for Users. Users provide Parameters, split by Space, when they run Command java xxx \u003cParameters\u003e copy an Array System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length) int[] src = {1,2,3,4,5}; int[] dest = new int[100]; System.arraycopy(src, 1, dest, 0, 2); // cioy start from the index with 1 in src // the copy Length is 2 // we can find the Elements that're copied start from the index with 0 in dest // dest = {2, 3, 0, 0, ..., 0} java.util.Arrays Methods ( static ) import java.util.Arrays; Arrays.sort(\u003cArray_Name\u003e); Arrays.binarySearch(\u003cArray_Name\u003e, key); ( returns index ) ","date":"2021-02-03","objectID":"/java-learning/:9:4","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"ArrayList Options ArrayList Initialization ArrayList\u003cDataType\u003e arraylist_name = new ArrayList\u003cDataType\u003e() int size() returns the Size of the ArrayList add(int Index, _DataType Item) add an Item into index contains(DataType Item) if the ArrayList contains the Item get(int index) get the Item through index int indexOf(DataType Item) returns the Index of the Item sort() sort the ArrayList toArray() transfer the ArrayList into an Array toString() transfer the ArrayList into a String P.S. For more Options, click here. ","date":"2021-02-03","objectID":"/java-learning/:9:5","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"LinkedList Options LinkedList Initialization LinkedList\u003cDataType\u003e list = new LinkedList\u003cDataType\u003e() int size() returns the Size of the LinkedList add((int index, )DataType Item) add an Item at the end of the LinkedList / index remove(int index) remove the index-th Item of the LinkedList get(int index) get the index-th Item of the LinkedList Object[] toArray() returns an Array composed by the Items of LinkedList P.S. For more Options, click here. ","date":"2021-02-03","objectID":"/java-learning/:9:6","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"HashMap Options HashMap Initialization HashMap\u003cDataType Key, DataType Value\u003e sites = new HashMap\u003cDataType Key, DataType Value\u003e() int size() returns the size of the HashMap value’s DataType get(DataType Key) returns the value of Key boolean containsKey(DataType Key) if the HashMap contains the Key-Value remove(DataType Key) remove the Item of the HashMap P.S. For more Options, click here. ","date":"2021-02-03","objectID":"/java-learning/:9:7","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"HashSet Options HashSet Initialization HashSet\u003cDataType\u003e sites = new HashSet\u003cDataType\u003e() int size() returns the size of the HashSet boolean contains(DataType Item) if the HashSet contains the Item remove(DataType Item) remove the Item of the HashSet P.S. For more Options, click here. ","date":"2021-02-03","objectID":"/java-learning/:9:8","tags":["Languages"],"title":"Java Learning","uri":"/java-learning/"},{"categories":["Learn"],"content":"Go Through LeetCode ","date":"2021-01-25","objectID":"/leetcode/:0:0","tags":["LeetCode"],"title":"LeetCode","uri":"/leetcode/"},{"categories":["Learn"],"content":"Recursion / Binary Tree ","date":"2021-01-25","objectID":"/leetcode/:1:0","tags":["LeetCode"],"title":"LeetCode","uri":"/leetcode/"},{"categories":["Learn"],"content":"112. Path Sum - simple recursion Discription: Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. Idea: What kind of traverse should we use? –\u003e Preorder ( why? ) What’s the Base-Case and what’s the Task for every single TreeNode? /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool hasPathSum(TreeNode* root, int targetSum) { if(root == NULL) return false; if(targetSum == root -\u003e val \u0026\u0026 root -\u003e left == NULL \u0026\u0026 root -\u003e right == NULL) return true; targetSum -= root -\u003e val; bool left = hasPathSum(root -\u003e left, targetSum); bool right = hasPathSum(root -\u003e right, targetSum); return left || right; } }; ","date":"2021-01-25","objectID":"/leetcode/:1:1","tags":["LeetCode"],"title":"LeetCode","uri":"/leetcode/"},{"categories":["Learn"],"content":"230. Kth Smallest Element in a BST Discription: Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Idea: What’s the Defination / Features of BST? What kind of traverse should we use? –\u003e Inorder ( why? ) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: // The most simple Resolution: Serealize the BST and push every element into a vector. // Return the k-1th element ( Vector besgins with 0 ). vector\u003cint\u003e nums; int kthSmallest(TreeNode* root, int k) { traverse(nums, root); // traverse(root, k); return nums[k-1]; } void traverse_withVector(vector\u003cint\u003e \u0026nums, TreeNode* root){ if(root == NULL) return; else{ traverse(nums, root -\u003e left); nums.push_back(root -\u003e val); traverse(nums, root -\u003e right); } } // Without Vector, use Recursion only. int count = 0; int result; void traverse(TreeNode* root, int k){ if(root == NULL) return; traverse(root -\u003e left, k); count++; if(count == k){ result = root -\u003e val; return; } traverse(root -\u003e right, k); } }; ","date":"2021-01-25","objectID":"/leetcode/:1:2","tags":["LeetCode"],"title":"LeetCode","uri":"/leetcode/"},{"categories":["Learn"],"content":"538. Convert BST to Greater Tree Discription: Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. As a reminder, a binary search tree is a tree that satisfies these constraints: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Idea: What kind of traverse should we use? –\u003e Inorder ( why? ) What’s the Base-Case and what’s the Task for every single TreeNode? class Solution { public: int sum = 0; TreeNode* convertBST(TreeNode* root) { if(root == NULL) return root; root -\u003e right = convertBST(root -\u003e right); root -\u003e val += sum; sum = root -\u003e val; root -\u003e left = convertBST(root -\u003e left); return root; } }; ","date":"2021-01-25","objectID":"/leetcode/:1:3","tags":["LeetCode"],"title":"LeetCode","uri":"/leetcode/"},{"categories":["Learn"],"content":"652. Find Duplicate Subtrees - hash table, serealization Discription: Given the root of a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with the same node values. Idea: What kind of traverse should we use? –\u003e Postorder ( why? ) How to compare subtrees that come from different roots? –\u003e Serealize the subtree to a String and store them into a Hash table ( unordered_map in C++). /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: unordered_map\u003cstring, int\u003e memo; vector\u003cTreeNode*\u003e res; vector\u003cTreeNode*\u003e findDuplicateSubtrees(TreeNode* root) { traverse(root, res); return res; } string traverse(TreeNode* root, vector\u003cTreeNode*\u003e\u0026 res){ if(root == NULL) return \"#\"; string left = traverse(root -\u003e left, res); string right = traverse(root -\u003e right, res); string result = left + ',' + right + ',' + to_string(root -\u003e val); if(memo.find(result) == memo.end()) memo[result]++; else if(memo[result] == 1){ memo[result]++; res.push_back(root); } else memo[result]++; return result; } }; Discription: Idea: ","date":"2021-01-25","objectID":"/leetcode/:1:4","tags":["LeetCode"],"title":"LeetCode","uri":"/leetcode/"},{"categories":["Learn"],"content":"Linked List ","date":"2021-01-25","objectID":"/leetcode/:2:0","tags":["LeetCode"],"title":"LeetCode","uri":"/leetcode/"},{"categories":["Learn"],"content":"19. Remove Nth Node From End of List ( Middle ) /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { private ListNode myFunc(ListNode head, int n){ ListNode slow = head, fast = head; while(n \u003e 0){ fast = fast.next; n--; } if(fast == null) return head.next; while(fast.next != null){ slow = slow .next; fast = fast.next; } slow.next = slow.next.next; return head; } public ListNode removeNthFromEnd(ListNode head, int n) { if(head == null) return head; head = myFunc(head, n); return head; } } ","date":"2021-01-25","objectID":"/leetcode/:2:1","tags":["LeetCode"],"title":"LeetCode","uri":"/leetcode/"},{"categories":["Learn"],"content":"141. Linked List Cycle ( Easy ) ( -\u003e HashSet? ) /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public boolean hasCycle(ListNode head) { if(head == null || head.next == null) return false; ListNode slow = head, fast = head; while(fast != null \u0026\u0026 fast.next != null){ slow = slow.next; fast = fast.next.next; if(slow == fast) return true; } return false; } } ","date":"2021-01-25","objectID":"/leetcode/:2:2","tags":["LeetCode"],"title":"LeetCode","uri":"/leetcode/"},{"categories":["Learn"],"content":"149. Reorder List ( Middle ) /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { private ListNode reverse(ListNode head){ // Reverse a List. if(head == null || head.next == null) return head; ListNode retNode = null; while(head != null){ ListNode nxt = head.next; head.next = retNode; retNode = head; head = nxt; } return retNode; } private ListNode findMid(ListNode head){ // Find the Middle Node of a List ( slow - fast ) ListNode slow = head, fast = head.next; while(fast != null \u0026\u0026 fast.next != null){ slow = slow.next; fast = fast.next.next; } return slow; } private ListNode merge(ListNode left, ListNode right){ // Merge 2 List. Here we use \"index\" to decide which List-Node to be chosen. // When we merge a list ascend, we can compare the Values of Nodes. ListNode retNode = new ListNode(-1); ListNode temp = retNode; int index = 0; while(left != null \u0026\u0026 right != null){ if(index % 2 == 0){ temp.next = left; left = left.next; } else if(index % 2 == 1){ temp.next = right; right = right.next; } temp = temp.next; index++; } if(left != null) temp.next = left; else temp.next = right; return retNode.next; } public void reorderList(ListNode head) { if(head == null || head.next == null) return; ListNode midNode = findMid(head); ListNode left = head; ListNode right = reverse(midNode.next); midNode.next = null; ListNode retNode = merge(left, right); head = retNode; return; } } ","date":"2021-01-25","objectID":"/leetcode/:2:3","tags":["LeetCode"],"title":"LeetCode","uri":"/leetcode/"},{"categories":["Learn"],"content":"Ideas ","date":"2021-01-17","objectID":"/algorithms/:0:0","tags":["Algorithms"],"title":"Algorithms -- Recursion","uri":"/algorithms/"},{"categories":["Learn"],"content":"Recursion What important is, NEVER JUMP INTO RECURSION. Actually… If it’s possible, you can jump into it… (Well… You can take a try:) ) In a Word, what the Blog above says, is that you must make sure that you know the very Defination of your Recursion Function, and trust that it can finish its Work perfectly. ","date":"2021-01-17","objectID":"/algorithms/:1:0","tags":["Algorithms"],"title":"Algorithms -- Recursion","uri":"/algorithms/"},{"categories":["Learn"],"content":"1. Recursion in List Figure out what does your Function proceedure with, what kind of value will it return. Consider about the Base-Case, with which we can end the recursion Deal with the rest part ( beyond the Base-Case ) recursively by using your Function. Proceedure the Details of Base-Case. 1.1. Reverse a complete-List listNode* reverse(ListNode* head){ // Base-Case if(head -\u003e next == NULL) return head; // With Nothing to do, because it's a single-element List. listNode* last = reverse(head -\u003e next); head -\u003e next -\u003e next = head; head -\u003e next = NULL; return last; } 1.2 Reverse the first n-element in a List listNode* successor = NULL; listNode* reverseN(listNode* head, int n){ if(n == 1){ successor = head.next; return head; } listNode* last = reverseN(head -\u003e next, n - 1); head -\u003e next = successor; head -\u003e next -\u003e next = head; return last; } 1.3 Reverse the [m, n] elements in a List listNode* reverseMN(listNode *head, int m, int n){ if(m == 1) return reverseN(head, n); /* Here we consider about the Situation by sub-List([head-\u003enext, end]). For this sub-List we begin with m-1, the length we need to proceedure is n - 1. */ head -\u003e next = reverseMN(head -\u003e next, m - 1, n - 1); return head; } 1.4 Reverse a List in K-elements Group Reverse a List in Iteration: listNode* reverse_Iteration(listNode* head){ listNode* prev, cur, nxt; cur = nxt = head; prev = NULL; while(cur != NULL){ // For given-Node case, we modify the loop: // while(cur != givenNode) nxt = cur -\u003e next; cur -\u003e next = prev; prev = cur; cur = nxt; } return prev; } 1.5 Reverse a List in K-elements Group listNode* reverseKGroup(listNode* head, int k){ if(head == NULL) return head; listNode* b; b = head; for(int i = 0; i \u003c k; i++){ if(b == NULL) return head; b = b -\u003e next; } listNode* newHead = reverse_givenNode(head, b); head -\u003e next = reverseKGroup(b, k); return newHead; } ","date":"2021-01-17","objectID":"/algorithms/:1:1","tags":["Algorithms"],"title":"Algorithms -- Recursion","uri":"/algorithms/"},{"categories":["Learn"],"content":"2. Recursion in Binary Tree What kind of order should be used, must know. 2.1 Traverse - preorder, inorder, postorder void traverse(TreeNode* root){ // Base-case if(root == NULL) return; cout \u003c\u003c root -\u003e val; // Preorder traverse(root -\u003e left); cout \u003c\u003c root -\u003e val; // Inorder traverse(root -\u003e right); cout \u003c\u003c root -\u003e val; // Postorder } ","date":"2021-01-17","objectID":"/algorithms/:1:2","tags":["Algorithms"],"title":"Algorithms -- Recursion","uri":"/algorithms/"},{"categories":["Learn"],"content":"Sort Algorithms ","date":"2021-01-17","objectID":"/algorithms/:2:0","tags":["Algorithms"],"title":"Algorithms -- Recursion","uri":"/algorithms/"},{"categories":["Learn"],"content":"Merge-Sort Ideas: sort On-Place. We need an aux Array. devide and conquer: devide Array into 2 Parts ( based on mid ) until the Base-Case, then we merge them. how to merge: copy the Elements to aux Array. Code: public class mergeSort{ public static void main(String[] args){ int[] nums = {9,8,7,6,5,4,3,2,1}; sort(nums); /* for(int i = 0; i \u003c nums.length; i++) System.out.print(nums[i]); */ } private static int[] aux; private static void merge(int[] a, int lo, int mid, int hi){ int i = lo; int j = mid + 1; // copy original Array to Aux[]: sort on Place. for(int k = i; k \u003c= hi; k++) aux[k] = a[k]; for(int k = lo; k \u003c= hi; k++){ if(i \u003e mid) a[k] = aux[j++]; else if(j \u003e hi) a[k] = aux[i++]; else if(aux[j] \u003c= aux[i]) a[k] = aux[j++]; else a[k] = aux[i++]; } } private static void sort(int[] nums, int lo, int hi){ if(hi \u003c= lo) return; int mid = lo + (hi - lo) / 2; sort(nums, lo, mid); sort(nums, mid + 1, hi); merge(nums, lo, mid, hi); } private static void sort(int[] a){ aux = new int[a.length]; sort(a, 0, a.length - 1); } } ","date":"2021-01-17","objectID":"/algorithms/:2:1","tags":["Algorithms"],"title":"Algorithms -- Recursion","uri":"/algorithms/"},{"categories":["Learn"],"content":"Quick Sort Ideas: devide and conquer: select a Standard, move it to the proper Position, then devide the Array into 2 Parts, sort them. how to move the Standard to the proper Position: a while - Loop. The left Side of the Standard should no greater than the Standard, the right Side should no less than it. sort the left Side and the right Side. Code: public class quickSort { public static void main(int[] nums) { // TODO Auto-generated method stub sort(nums, 0, nums.length - 1); } private static void sort(int[] a, int lo, int hi) { if(hi \u003c= lo) return; int j = partition(a, lo, hi); sort(a, lo, j - 1); sort(a, j + 1, hi); } private static int partition(int[] a, int lo, int hi) { int i = lo, j = hi + 1; int v = a[lo]; while(true) { while(a[++i] \u003c v) { if(i == hi) break; } while(v \u003c a[--j]) { if(j == lo) break; } if(i \u003e= j) break; swap(a, i, j); } swap(a, lo, j); return j; } private static void swap(int[] a, int i, int j) { int temp = a[i]; a[i] = a[j]; a[j] = temp; } } ","date":"2021-01-17","objectID":"/algorithms/:2:2","tags":["Algorithms"],"title":"Algorithms -- Recursion","uri":"/algorithms/"},{"categories":["Learn"],"content":"Lecture by Andrew Ng, Coursera ","date":"2020-12-18","objectID":"/machine-learning/:0:0","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Basic Concepts \u0026 Linear Regression ","date":"2020-12-18","objectID":"/machine-learning/:1:0","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Supervised Learning vs. Unsupervised Learning Supervised Learning: In supervised learning, we are given a data set and already know what our correct output should look like, having the idea that there is a relationship between the input and the output. Training Data already has the value, which our Function should predict for a new, strange input. i.e, In the case below, we want to get a function, so that we can calculate the price of a house to be sold. We have 4 Training Data in this table and each Data has 4 Features that have a influence on its' price ( we call it as Multi-Features. It’ll be discussed later:) ). It’s devided in Regression and Classification Problems Size Number of Bedrooms Number of Floors Age(years) Price(1000$) $TrainingData_1$ 2104 5 1 45 460 $TrainingData_2$ 1416 3 2 40 232 $TrainingData_3$ 1534 3 2 30 315 $TrainingData_4$ 852 2 1 36 178 … … … … … … ($x_1$) ($x_2$) ($x_3$) ($x_4$) ($x_5$) Unsupervised Learning Unsupervised learning, on the other hand, allows us to approach problems with little or no idea what our results should look like. We can derive structure from data where we don’t necessarily know the effect of the variables. ","date":"2020-12-18","objectID":"/machine-learning/:1:1","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Regression vs. Classification Regression: The Value we want to predict is continious instead of discrete. E.g., the Price of a House. In a regression problem, we are trying to predict results within a continuous output, meaning that we are trying to map input variables to some continuous function. Classification: As its' name, we want to devide the input in different classes. E.g., After training, with the help of the color, weight, outlook and smel ( Features ), we want to predict if the coffee beans we have come from Arabica or Robusta. In a classification problem, we are instead trying to predict results in a discrete output. In other words, we are trying to map input variables into discrete categories. ","date":"2020-12-18","objectID":"/machine-learning/:1:2","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Linear Regression with 1 Variable / Feature Hypothesis Function $\\hat y = h_\\theta = \\theta_0 + \\theta_1x$ Cost Function $J(\\theta_0, \\theta_1) = \\frac{1}{2m} \\sum_{i=1}^m(\\hat y_i - y_i)^2$ $\\rarr J(\\theta_0, \\theta_1) = \\frac{1}{2m} \\sum_{i=1}^m(h_\\theta(x_i) - y_i)^2$ Optimize Gradient Descent. More specifically, repeat: $tmp_0 = \\theta_0 - \\alpha\\frac{\\partial}{\\theta_0}{J(\\theta_0, \\theta_1)}$ $\\rarr tmp_0 = \\theta_0 - \\alpha\\frac{1}{m}\\sum_{i=1}^m{(h_\\theta(x_i) - y_i)}$ $tmp_1 = \\theta_1 - \\alpha\\frac{\\partial}{\\theta_1}{J(\\theta_0, \\theta_1)}$ $\\rarr tmp_1 = \\theta_1 - \\alpha\\frac{1}{m}\\sum_{i=1}^m{((h_\\theta(x_i) - y_i)x_1)}$ $\\theta_0 = tmp_0$ $\\theta_1 = tmp_1$ We call $\\alpha$ Learning Rate. Its' value has influence on the speed, how fast we can find the parameters, with that we can reach a local optimal value. When $\\alpha$ too large / too small is: too large: we might miss the parameters, which can help us get the local optimal value. too small: We need more iterations ( Baby Steps / more time ). We can make the judge, whether $\\alpha$ too large / small ist by drawing the plot of iterations - $J(\\theta_0, \\theta_1)$: It should be lower. Otherwise is $\\alpha$ too large. We can start $\\alpha$ from 0.001, …, 0.01, …, 0.1. And Andrew Ng advises us to use 3 times ( 0.001, 0.003, 0.01, 0.03, 0.1 ) to try it. ","date":"2020-12-18","objectID":"/machine-learning/:1:3","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Multiple Features and Matrix Vector: A vector is a Matrix with one Column and many rows. E.g., $\\begin{bmatrix}x_0 \\\\ x_1 \\\\x_2 \\\\x_3 \\end{bmatrix}$ Hypothesis: We use the table above as example, we have 4 Training Data and each of them has 4 Features. According to this, we should have 4+1 parameters $\\theta_0-\\theta_4$. We write the Hypothesis below: $h_\\theta(x^i) = \\theta_0 + \\sum_{j=1}^4\\theta_jx_j^i$ $x_i^j$ here means the jth Feature of the ith Training Data. Actually we can add a Feature $x_0 \\equiv 1$, then we can use the Matrix. So that we can write the Equation above as below: $h_\\theta(x^i) = \\sum_{j=0}^4\\theta_jx_j^i$ We let: $\\Theta = \\begin{bmatrix}\\theta_0, \\theta_1, \\theta_2, \\theta_3, \\theta_4\\end{bmatrix}$, $X = \\begin{bmatrix} x^1_0 \u0026 x^2_0 \u0026 x^3_0 \u0026 x^4_0 \\\\ x^1_1 \u0026 x^2_1 \u0026 x^3_1 \u0026 x^4_1 \\\\ x^1_2 \u0026 x^2_2 \u0026 x^3_2 \u0026 x^4_2 \\\\ x^1_3 \u0026 x^2_3 \u0026 x^3_3 \u0026 x^4_3 \\\\ x^1_4 \u0026 x^2_4 \u0026 x^3_4 \u0026 x^4_4 \\end{bmatrix}$. So that $h_\\theta(x^i) = \\Theta * i_{th}$ column of $X$. In Matrix $X$, element $x_0^i \\equiv 1$. We can also calculate $\\Theta * X$ directly, the $i_{th}$ colum is the value of $h_\\theta(x^i)$. Cost Function: Assume we have m Training Data, each of them has n Features. $J(\\theta_0, \\theta_1, … \\theta_n) = \\frac{1}{2m}\\sum_{i=1}^m(h_\\theta(x^i) - y^i)^2$ Gradien Descent: repeat: $tmp_i = \\theta_i - \\alpha\\frac{\\partial}{\\partial\\theta_i}J(\\theta_0, \\theta_1, …, \\theta_n)$ $\\rarr tmp_i = \\theta_i - \\alpha\\frac{1}{m}\\sum_{i=1}^m(h_\\theta(x^i) - y^i)* x^i)$ $\\theta_i = tmp_i$ ","date":"2020-12-18","objectID":"/machine-learning/:1:4","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Feature Scaling We use this technique when the range of Features have great Difference. E.g., $0 \\leq x_1 \\leq 2000, 0 \\leq x_2 \\leq 5$, then we can $x_1 \\coloneqq \\frac{x_1}{2000}, x_2 \\coloneqq \\frac{x_2}{5}.$ This helps with the speed up of the Gradient Descent. Andrew Ng advices that scaling all Features approximately into the range [-1, 1]. We can also scale the Features by using this: $x_i = \\frac{x_i - \\mu_i}{s_i}$ Here $\\mu_i$ is the average value of Feature $x_i$, $s_i$ is normally $value_{max} - value_{min}$. ","date":"2020-12-18","objectID":"/machine-learning/:1:5","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Normal Equation The Method to solve for $\\Theta$ analytically: $\\Theta = (X^TX)^{-1}X^Ty$ can minimize the $J(\\theta)$. $x^i = \\begin{bmatrix}x_0^i, x_1^i, …, x_n^i\\end{bmatrix}$ $X = \\begin{bmatrix} x_0^1 \u0026 x_1^1 \u0026 {…} \u0026 x_n^1 \\\\ x_0^2 \u0026 x_1^2 \u0026 {…} \u0026 x_n^2 \\\\ … \u0026 … \u0026 … \u0026 … \\\\x_0^m \u0026 x_1^m \u0026 {…} \u0026 x_n^m \\end{bmatrix}$ In this Matrix, we write each row the Features of one Training Data. $y = \\begin{bmatrix}y^{(1)}\\\\…\\\\y^{(m)}\\end{bmatrix}$ Suppose $m \\leq n$, then is $X^TX$ is degenerated. The following table can helps us decide, when to use Normal Equation, when to use Gradient Descent. Normal Equation Gradient Descent No need to choose $\\alpha$. May have “Baby Step” issue, or miss the local optimal value when $\\alpha$ too large. Can be slow when n ( Number of Features ) too large is. Works fine even when n large is. Some Matrix is singular or degenerated. $n \\leq 10,000$ $n \u003e 10,000$ Reasons of uninvertibility of Matrix $(X^TX)^{-1}$: Redundant Elements: linear depent. E.g., $x_1 = $size in $feet^2$, $x_2$ = size in $m^2$. Too many Features: Just delete some of them, or use regulization ( discuss later ). ","date":"2020-12-18","objectID":"/machine-learning/:1:6","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Logistic Regression \u0026 Overfitting \u0026 Regularization ","date":"2020-12-18","objectID":"/machine-learning/:2:0","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Logistic Regression - Classification Examples: Email (Spam / Not Spam), Online Transactions: Fraudulent ( Yes / No ) ? $y \\isin {0, 1} \\begin{cases} 0 \u0026\\text{Negative Class} \\\\ 1 \u0026\\text{Positive Class} \\end{cases}$ p.s. In multi-class Prolems this set can have more than 2 elements. What if we use linear Regression in a classfication problem? $h_\\theta(x) = \\theta^Tx\u003c 0$ or $\u003e 1$ In Logistic Regression, it shouled always be: $0 \\leq h\\theta(x) \\leq 1$_. So we do the following transformation, then we get the Hypothesis: $h_\\theta(x) = g(\\theta^Tx)$ Then we use Sigmoid Function / Logistic Function: $g(z) = \\frac{1}{1 + e^{-z}}$ We have now: $h_\\theta(x) = \\frac{1}{1 + e ^ {-\\theta^Tx}}$ This Function $h_\\theta(x)$ comes out the result that estimated probability that $y = 1$ on input x. We can also write it in the following Form: $h_\\theta(x) = P(y = 1 | x; \\theta)$ $\\rarr$ Probability that $y = 1$, given $x$, parameterized by $\\theta$. $P(y = 1 | x; \\theta) + P(y = 0 | x; \\theta) = 1$ ","date":"2020-12-18","objectID":"/machine-learning/:2:1","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Deciding Boundary The decision boundary is the line that separates the area where y = 0 and where y = 1. It is created by our hypothesis function. Linear Non-Linear The way our logistic function g behaves is that when its input is greater than or equal to zero, its output is greater than or equal to 0.5: $g(z) \\geq 0.5$ $\\text{when}\\ z \\geq 0$ Remeber: $z = 0, e^0 = 1\\Rightarrow \\ g(z) = \\frac{1}{2}$ $z \\rarr \\infty, e^{-\\infty}\\rarr \\ 0 \\Rightarrow \\ g(z) = 1$ $z \\rarr -\\infty, e^{\\infty}\\rarr \\ \\infty \\Rightarrow \\ g(z) = 0$ ","date":"2020-12-18","objectID":"/machine-learning/:2:2","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Cost Function Training Set: ${(x^{(1)}, y^{(1)}), (x^{(2)}, y^{(2)}), …, (x^{(m)}, y^{(m)})}$, m examples x $\\isin \\begin{bmatrix}x_0 \\\\ x_1 \\\\ … \\\\ x_m\\end{bmatrix}, x_0 \\equiv 1, y \\isin (0, 1)$ $h_\\theta(x) = \\frac{1}{1 + e ^ {-\\theta^Tx}}$ Brief Review: Cost Function in Linear Regression: $J(\\theta) = \\frac{1}{m}\\sum_{i=1}^m\\frac{1}{2}(h_\\theta(x^{(i)} - y^{(i)})^2$ $Cost(h_\\theta(x), y) = \\frac{1}{2}(h_\\theta(x) - y)^2$ We cannot use the same cost function that we use for linear regression because the Logistic Function will cause the output to be wavy, causing many local optima. In other words, it will not be a convex function. $Cost(h_\\theta(x), y) = \\begin{cases}-log(h_\\theta(x))\u0026\\text{if y = 1}\\\\-log(1 - h_\\theta(x)) \u0026\\text{if y=0}\\end{cases}$ if $y = 1, h_\\theta(x) = 1 \\rarr Cost = 0$. But as $h_\\theta(x) \\rarr 0, Cost \\rarr \\infty$ Predict $P(y=1|x; \\theta) = 0$, but $y = 1$, we’ll penalize learning algorithm by a very large cost. We can also write it like below: $Cost(h_\\theta(x), y) = -ylog(h_\\theta(x)) - (1-y)log(1 - h_\\theta(x))$ ","date":"2020-12-18","objectID":"/machine-learning/:2:3","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Gradient Descent $J(\\theta) = \\frac{1}{m}\\sum_{i=1}^mCost(h_\\theta(x^{(i)}), y^{(i)})$ $\\rarr J(\\theta) = -\\frac{1}{m}[\\sum_{i=1}^my^{(i)}log(h_\\theta(x^{(i)}) - y^{(i)}) + (1 - y^{(i)})log(1 - h_\\theta(x^{(i)}))]$ Repeat: $\\theta_j := \\theta_j - \\alpha\\frac{\\partial}{\\partial\\theta_j}J(\\theta)$ $\\rarr \\theta_j := \\theta_j - \\alpha\\frac{1}{m}\\sum_{i=1}^m(h_\\theta(x^{(i)}) - y^{(i)})x^{(i)}_j$ It looks identical to Linear Regression. BUT: $h_\\theta(x) = \\theta^Tx$ in Linear Regression In Logistic Regression is $h_\\theta(x) = \\frac{1}{1 + e^{-\\theta^Tx}}$ A vectorized implementation is: $\\theta := \\theta - \\frac{\\alpha}{m}X^T(g(X\\theta) - y)$ ","date":"2020-12-18","objectID":"/machine-learning/:2:4","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Anvanced Optimization Algorithms: Gradient Descent Conjugate gradient BFGS L-BFGS Advantages: No need to manually choose $\\alpha$ Often faster than gradient descent Disadvantages: More complex We can write a single function that returns both of these: function [jVal, gradient] = costFunction(theta) jVal = [...code to compute J(theta)...]; gradient = [...code to compute derivative of J(theta)...]; end Then we can use octave’s “fminunc()” optimization algorithm along with the “optimset()” function that creates an object containing the options we want to send to “fminunc()”. options = optimset('GradObj', 'on', 'MaxIter', 100); initialTheta = zeros(2,1); [optTheta, functionVal, exitFlag] = fminunc(@costFunction, initialTheta, options); ","date":"2020-12-18","objectID":"/machine-learning/:2:5","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Multi-class Classification: one-vs-all ( one-vs-rest ) E.g., Email foldering / tagging: Work, Friends, Family, Hobby ($y=1, y=2, y=3, y=4$) We are basically choosing one class and then lumping all the others into a single second class. We do this repeatedly, applying binary logistic regression to each case, and then use the hypothesis that returned the highest value as our prediction. $h_\\theta^{(i)} = P(y = i | x; \\theta)$ $(i=1,2,3)$ Train a logistic regression classifier $h_\\theta^{(i)}(x)$ for each class $i$ to predict the probability that $y=i$. On a new input $x$, to make a prediction, pick the class $i$ that maximizes $max_ih_\\theta^{(i)}(x)$. ","date":"2020-12-18","objectID":"/machine-learning/:2:6","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Overfitting Definiation If we have too many Features, the learned hypothesis may fit the training set very well, but fail to generalize to new examples. $\\darr$ On Logistic Regression $\\darr$ Underfitting, or high bias, is when the form of our hypothesis function h maps poorly to the trend of the data. It is usually caused by a function that is too simple or uses too few features. At the other extreme, overfitting, or high variance, is caused by a hypothesis function that fits the available data but does not generalize well to predict new data. It is usually caused by a complicated function that creates a lot of unnecessary curves and angles unrelated to the data. Adressing Overfitting: Reduce number of Features Manually select which Features to keep Model selection algorithm Regularization Keep all the Features, but reduce magnitude / values of parameters $\\theta$. Works well when we have a lot of Features, each of which contributes a bit to predicting $y$. ","date":"2020-12-18","objectID":"/machine-learning/:2:7","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Regularization Small Values for parameters $\\theta_0, \\theta_1, …, \\theta_n$ “Simpler” hypothesis Less prone to overfitting E.g. Housing: Features: $x_1, x_2, …, x_{100}$ Parameters: $\\theta_0, \\theta_1, …, \\theta_n$ $J(\\theta) = \\frac{1}{2m}[\\sum_{i=1}^m(h_\\theta(x^{(i)} - y^{(i)})^2 + \\lambda\\sum_{j=1}^{n}\\theta_j^2]$. We pinelize only $\\theta_{i \u003e 0}$ $\\lambda$ is called Regulization Parameter. It determines how much the costs of our theta parameters are inflated. When the $\\lambda$ too large is, $h_\\theta(x) = \\theta_0$ (Because this can make $\\theta_{i \u003e 0} \\thickapprox 0$) Regularized Linear Regression Cost Function: $J(\\theta) = \\frac{1}{2m}[\\sum_{i=1}^m(h_\\theta(x^{(i)} - y^{(i)})^2 + \\lambda\\sum_{j=1}^{n}\\theta_j^2]$. Gradient Descent: $\\theta_0 := \\theta_0 - \\alpha \\frac{1}{m}\\sum_{i=1}^m(h_\\theta(x^{(i)}) - y^{(i)})(x_0 \\equiv 1))$ $\\theta_{j \u003e 0} := \\theta_j - \\alpha[\\frac{1}{m}\\sum_{i=1}^m(h_\\theta(x^{(i)} - y^{(i)}))x^{(i)} + \\frac{\\lambda}{m}\\theta_j]$ $\\rarr \\theta_{j \u003e 0} := \\theta_j(1- \\alpha\\frac{\\lambda}{m}) - \\alpha\\frac{1}{m}\\sum_{i=1}^m(h_\\theta(x^{(i)} - y^{(i)}))x^{(i)}$ In the Equation above, $ \\theta_j(1- \\alpha\\frac{\\lambda}{m}) \u003c 1$. We can be sure that the parameter will be smaller in each iteration. Normal Equition: $X = \\begin{bmatrix}(x^{(i)})^T\\\\…\\\\(x^{(m)})^T\\\\\\end{bmatrix}$ $y = \\begin{bmatrix}y^{(1)}\\\\…\\\\y^{(m)}\\end{bmatrix}$ $\\theta = (X^TX + \\lambda\\begin{bmatrix}0 \u0026 0 \u0026 0\\\\0 \u0026 1 \u00260 \\\\ 0 \u0026 0 \u0026 1\\end{bmatrix})^{-1}X^Ty$ The Elements in the Matrix next to $\\lambda[\\text{size} = (n + 1)\\times (n + 1)]$ looks like: $e_{11} = 0,\\ e_{i \\not = j} = 0,\\ e_{i=j\\not = 1} = 1$. (With 0 at the top left and 1’s down the diagonal, with 0’s everywhere else.) if $\\lambda \u003e 0$, the Matrix $(X^TX + \\lambda\\begin{bmatrix}0 \u0026 0 \u0026 0\\\\0 \u0026 1 \u00260 \\\\ 0 \u0026 0 \u0026 1\\end{bmatrix})$ can always transport. Regularized Logistic Regression Cost Function: $J(\\theta) = -[\\frac{1}{m}\\sum_{i=1}^my^{(i)}logh_\\theta(x^{(i)}) + (1 - y^{(i)})log(1 - h_\\theta(x^{(i)}))] + \\frac{\\lambda}{2m}\\sum_{j=1}^m\\theta_j^2$ Gradient Descent: $\\theta_0 := \\theta_0 - \\alpha \\frac{1}{m}\\sum_{i=1}^m(h_\\theta(x^{(i)}) - y^{(i)})(x_0 \\equiv 1))$ $\\theta_{j \u003e 0} := \\theta_j - \\alpha[\\frac{1}{m}\\sum_{i=1}^m(h_\\theta(x^{(i)} - y^{(i)}))x^{(i)} + \\frac{\\lambda}{m}\\theta_j]$ $\\rarr \\theta_{j \u003e 0} := \\theta_j(1- \\alpha\\frac{\\lambda}{m}) - \\alpha\\frac{1}{m}\\sum_{i=1}^m(h_\\theta(x^{(i)} - y^{(i)}))x^{(i)}$ Here $h_\\theta(x) = \\frac{1}{1 + e^{-\\theta^Tx}}$ ","date":"2020-12-18","objectID":"/machine-learning/:2:8","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Non-Linear Hypothesis - Neural Networks What should we do when we proceed an Image? Transfer it into a grayscale-image. It has only $\\frac{1}{3}$ Features that RGB-image has. ","date":"2020-12-18","objectID":"/machine-learning/:3:0","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Neural Network Origins: Algorithms that try to mimic the brain. Neuron Model: Logistic Unit $x = \\begin{bmatrix}x_0\\\\x_1\\\\…\\\\x_n\\end{bmatrix}$ (Just a Vector of Features.) $\\theta = \\begin{bmatrix}\\theta_0\\\\\\theta_1\\\\…\\\\\\theta_n\\end{bmatrix}$ In this Picture, $x_0$ is called the bias unit or the bias neuron. And $x_0 \\equiv 1$ There’s a sigmoid(logistic) Activaition Function in this Picture $\\theta$( “Parameters” ) are called as “Weights” here. Presentations: $a_i^{(j)}: $ Activation of Unit $i$ in Layer $j$ Input Layer is the 1st Layer. $\\Theta^{(j)}: $ Matrix of weights controlling function mapping from layer $j$ to layer $j+1$ $\\theta^{(1)}: 3\\times 4$ $a_1^{(2)} = g(\\Theta_{10}^{(1)}x_0 + \\Theta_{11}^{(1)}x_1 + \\Theta_{12}^{(1)}x_2 + \\Theta_{13}^{(1)}x_3)$ $a_2^{(2)} = g(\\Theta_{20}^{(1)}x_0 + \\Theta_{21}^{(1)}x_1 + \\Theta_{22}^{(1)}x_2 + \\Theta_{23}^{(1)}x_3)$ $a_1^{(3)} = g(\\Theta_{30}^{(1)}x_0 + \\Theta_{31}^{(1)}x_1 + \\Theta_{32}^{(1)}x_2 + \\Theta_{33}^{(1)}x_3)$ $h_{\\Theta}(x) = a_1^{(3)} = g(\\Theta_{10}^{(2)}a_0^{(2)} + \\Theta_{11}^{(2)}a_1^{(2)} + \\Theta_{12}^{(2)}a_2^{(2)} + \\Theta_{13}^{(2)}a_3^{(2)})$ ⚠️ If networks has $s_j$ units in layer $j$, $s_{j+1}$ Units in layer $j+1$, then $\\Theta^{(j)}$ will be of dimension $s_{j+1} \\times (s_j + 1)$ ( Because there’s a Bias Unit in j+1th Layer ). And it should be randomly intialized. Vectorized Implementation \u0026 Forward Propagation: $x = \\begin{bmatrix}x_0\\\\x_1\\\\x_2\\\\x_3\\end{bmatrix}$ $z^{(2)} = \\begin{bmatrix}z_1^{(2)}\\\\z_2^{(2)}\\\\z_3^{(2)}\\end{bmatrix}$ $z^{(2)} = \\Theta^{(1)}x$ We define the Input Layer as $a^{(1)}$. Then we can write in this Form: $z^{(2)} = \\Theta^{(1)}a^{(1)}$ $a^{(2)} = g(z^{(2)})$ (Here $g$ is the Sigmoid Function.) Add $a_0^{(2)} = 0$ $z^{(3)} = \\Theta^{(2)}a^{(2)}$ $h_\\theta(x) = a^{(3)} = g(z^{(3)})$ In a word, Setting $x = a^{(1)}$, we can write: $z^{(j)} = \\Theta^{(j - 1)}a^{(j - 1)}$ $a^{(j)} = g(z^{(j)})$ $h_\\Theta(x) = a^{(j + 1)} = g(z^{(j + 1)})$ We can through choosing $\\theta$ to realize AND, OR, NOT, XOR, XNOR… ","date":"2020-12-18","objectID":"/machine-learning/:3:1","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Cost Function Definitions: Training Datas: ${(x^{(1)}, y^{(1)}), (x^{(2)}, y^{(2)}), …, (x^{(m)}, y^{(m)})}$ $L = $ total no. of Layers in network $s_l = $ no. of units ( not counting bias unit ) in layer $l$. Classification Problems: Binary Classification Multi-class Classification ( K classes ) $y = 0$ or $1$ $y \\isin \\R^K$, E.g. $\\begin{bmatrix}1\\\\0\\\\0\\\\0\\end{bmatrix}$, $\\begin{bmatrix}0\\\\1\\\\0\\\\0\\end{bmatrix}$, $\\begin{bmatrix}0\\\\0\\\\1\\\\0\\end{bmatrix}$, $\\begin{bmatrix}0\\\\0\\\\0\\\\1\\end{bmatrix}$ 1 output unit K output units Logistic Regression: Brief Review: $J(\\theta) = -\\frac{1}{m}\\sum_{i=1}^{m}[y^{(i)}log(h_\\theta(x^{(i)})) + (1 - y^{(i)})log(1 - h_\\theta(x^{(i)}))] + \\frac{\\lambda}{2m}\\sum_{j=1}^{n}\\theta_j^2$ Neural Network: $h_\\Theta(x) \\isin \\R^K, (h_\\Theta(x))_i = i^{th}$ Output $J(\\Theta) = -\\frac{1}{m}[\\sum_{i=1}^{m}\\sum_{k=1}^{K}y_k^{(i)}log(h_\\Theta(x^{(i)}))_k + (1 - y_k^{(i)})log(1 - (h_\\Theta(x^{(i)}))_k)] + \\frac{\\lambda}{2m}\\sum_{l = 1}^{L - 1}\\sum_{i = 1}^{s_l}\\sum_{j = 1}^{s_{l+1}}(\\Theta_{ji}^{l})^2$ ","date":"2020-12-18","objectID":"/machine-learning/:3:2","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Backpropagation Algorithm Gradiet Descent, we need to compute: $J(\\Theta)$ $\\frac{\\partial}{\\partial\\Theta_{ij}^{(l)}}J(\\Theta)$ $J(\\Theta) = -\\frac{1}{m}[\\sum_{i=1}^{m}\\sum_{k=1}^{K}y_k^{(i)}log(h_\\Theta(x^{(i)}))_k + (1 - y_k^{(i)})log(1 - (h_\\Theta(x^{(i)}))_k)] + \\frac{\\lambda}{2m}\\sum_{l = 1}^{L - 1}\\sum_{i = 1}^{s_l}\\sum_{j = 1}^{s_{l+1}}(\\Theta_{ji}^{l})^2$ Intuition: $\\delta_j^{(l)}$ = “error” of node $j$ in layer $l$. For each output Unit ( Layer = 4 ): $\\delta_j^{(4)} = a_j^{(4)} - y_j$ $a_j^{(4)} = (h_\\theta(x))_j$ We have: $\\delta^{(4)} = a^{(4)} - y$ Then we execute the following Operations: $\\delta^{(3)} = (\\Theta^{(3)})^T\\delta^{(4)} .* g'(z^{(3)})$ $\\delta^{(2)} = (\\Theta^{(2)})^T\\delta^{(3)} .* g'(z^{(2)})$ Here $g'(z^{(n)}) = a^{(n)} .* (1 - a^{(n)})$ $\\delta^{(l)} = ((\\Theta^{(l)})^T\\delta^{(l + 1)}) .* a^{(l)} .* (1 - a^{(l)})$ Specifically: Training Set: ${(x^{(1)}, y^{(1)}), (x^{(2)}, y^{(2)}), …, (x^{(m)}, y^{(m)})}$ Set $\\Delta_{ij}^{(l)} = 0$, for all $i, j, l$ For $i = 1$ to $m$: Set $a^{(1)} = x^{(i)}$ Perform forward propagation to compute $a^{(l)}$ for $l = 2, 3, …, L$ Using $y^{(i)}$, compute $\\delta^{(L)} = a^{(L)} - y^{(i)}$ Compute $\\delta^{(L - 1)}, \\delta^{(L - 2)}, …, \\delta^{(2)}$ $\\Delta_{ij}^{(l)}:= \\Delta_{ij}^{(l)} + a_j^{(l)}\\delta_i^{(l+1)}$ Vectorization: $\\Delta^{(l)} := \\Delta^{(l)} + \\delta^{(l + 1)}(a^{(l)})^T$ $D_{ij}^{(l)} := \\frac{1}{m}(\\Delta_{ij}^{(l)} + \\lambda\\Theta_{ij}^{(l)})$ if $j \\neq 0$ $D_{ij}^{(l)} := \\frac{1}{m}\\Delta_{ij}^{(l)}$ if $j = 0$ ","date":"2020-12-18","objectID":"/machine-learning/:3:3","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Training Neural Network Randomly initialize weights Implement forward propagation to get $h_\\Theta(x^{(i)})$ for any $y^{(i)}$ Implement code to compute cost function $J(\\Theta)$ Implement backpropagation to compute partial derivates $\\frac{\\partial}{\\partial\\Theta_{jk}^{(l)}} J(\\Theta)$ Use Gradient Checking to compare $\\frac{\\partial}{\\partial\\Theta_{jk}^{(l)}} J(\\Theta)$ computed using back propagation vs. using numerical estimate of gradient of $J(\\Theta)$, then disable gradient checking code. Use Gradient Descent or advanced optimization method with backpropagation to try to minimize $J(\\Theta)$ as a function of parameters $\\Theta$ for i = 1:m, Perform forward propagation and backpropagation using example (x(i),y(i)) (Get activations a(l) and delta terms d(l) for l = 2,...,L ","date":"2020-12-18","objectID":"/machine-learning/:3:4","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Evaluating Hypothesis Split the labeled data randomly into 2 Parts: Training Set ( 70% ) and Test Set ( 30% ). Learn the parameter $\\theta$ from Training data Computing test Set error: In Linear Regression: $J(\\theta) = \\frac{1}{2m_{test}}\\sum_{i = 1}^{m_{test}}(J(x_{test}^{(i)}) - y_{test}^{(i)})^2$ In Logistic Regression: $J(\\theta) = -\\frac{1}{m_{test}}\\sum_{i = 1}^{m_{test}}[y^{(i)}logh_{\\theta}(x^{(i)}_{test}) + (1 - y^{(i)})log(1 - h_{\\theta}(x^{(i)}_{test}))]$ Misclassification error ( 0/1 multiclassification error ): $err(h_{\\theta}(x), y) = 1$, if $h_{\\theta}(x) \\leq 0.5, y = 1 | h_{\\theta}(x) \\geq 0.5, y = 0$ $Test_{error} = \\frac{1}{m_{test}}\\sum_{i = 1}^{m_{test}}err(h_{\\theta}(x_{test}^{(i)}), y^{(i)})$ ","date":"2020-12-18","objectID":"/machine-learning/:3:5","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Model Selection, Training, Validation and Test Model Selection 1). $h_{\\theta}(x) = \\theta_0 + \\theta_1(x) \\rarr \\theta^{(1)} \\rarr J_{test}(\\theta^{(1)})$ 2). $h_{\\theta}(x) = \\theta_0 + \\theta_1(x) + \\theta_2^2(x) \\rarr \\theta^{(2)} \\rarr J_{test}(\\theta^{(2)})$ 3). $h_{\\theta}(x) = \\theta_0 + \\theta_1(x) + \\theta_2^2(x) + \\theta_3^3(x) \\rarr \\theta^{(3)} \\rarr J_{test}(\\theta^{(3)})$ … 10). $h_{\\theta}(x) = \\theta_0 + \\theta_1(x) + \\theta_2^2(x) + \\theta_3^3(x) + … + \\theta_{10}^{10}(x) \\rarr \\theta^{(10)} \\rarr J_{test}(\\theta^{(10)})$ We should’t use the chosen $\\theta^{(5)}$ to test how well it fits in our Test Set. Because we become it from Training Set, and the Test Set has the same Dimension as the Training Set. It lacks of Generalization on New Data Set. Thus, we split the Data Set into 3 pieces: Training Set ( 60% ), Cross Validation Set ( 20% ), Test Set ( 20% ). Train ( Books ) / Validation ( Homework ) / Test Error ( Examination ) Training Error $J_{train}(\\theta) = \\frac{1}{2m_{train}}\\sum_{i = 1}^{m_{train}}(h_{\\theta}(x_{train}^{(i)}) - y_{train}^{(i)})^2$ Validation Error $J_{cv}(\\theta) = \\frac{1}{2m_{cv}}\\sum_{i = 1}^{m_{cv}}(h_{\\theta}(x_{cv}^{(i)}) - y_{cv}^{(i)})^2$ Test Error $J_{test}(\\theta) = \\frac{1}{2m_{test}}\\sum_{i = 1}^{m_{test}}(h_{\\theta}(x_{test}^{(i)}) - y_{test}^{(i)})^2$ 1). $h_{\\theta}(x) = \\theta_0 + \\theta_1(x) \\rarr \\theta^{(1)} \\rarr J_{cv}(\\theta^{(1)})$ 2). $h_{\\theta}(x) = \\theta_0 + \\theta_1(x) + \\theta_2^2(x) \\rarr \\theta^{(2)} \\rarr J_{cv}(\\theta^{(2)})$ 3). $h_{\\theta}(x) = \\theta_0 + \\theta_1(x) + \\theta_2^2(x) + \\theta_3^3(x) \\rarr \\theta^{(3)} \\rarr J_{cv}(\\theta^{(3)})$ … 10). $h_{\\theta}(x) = \\theta_0 + \\theta_1(x) + \\theta_2^2(x) + \\theta_3^3(x) + … + \\theta_{10}^{10}(x) \\rarr \\theta^{(10)} \\rarr J_{cv}(\\theta^{(10)})$ Pick $h_{\\theta}(x) = \\theta_0 + \\theta_1(x) + \\theta_2^2(x) + \\theta_3^3(x) + \\theta_4^4(x)$, Estimate generalization error for test set $J_{test}(\\theta^{(4)})$ Diagnosing Bias ( Too high -\u003e underfit ) vs. variance ( Too high -\u003e overfit ) Training Error $J_{train}(\\theta) = \\frac{1}{2m_{train}}\\sum_{i = 1}^{m_{train}}(h_{\\theta}(x_{train}^{(i)}) - y_{train}^{(i)})^2$ Validation Error $J_{cv}(\\theta) = \\frac{1}{2m_{test}}\\sum_{i = 1}^{m_{cv}}(h_{\\theta}(x_{cv}^{(i)}) - y_{cv}^{(i)})^2$ Draw the “Degree of polynomioal d - Error” plot. In this Plot draw the $J_{train}(\\theta), J_{cv/test}(\\theta)$. Then we can make sure wether it’s high bias or high variance. Bias ( Underfit, when d too small ): $J_{train}(\\theta)$ will be high $J_{train}(\\theta) \\approx J_{cv}(\\theta)$ Variance ( Overfit, when d too large ): $J_{train}(\\theta)$ will be low $J_{cv}(\\theta) \\gg J_{train}(\\theta)$ Regularization and bias / variance Linear Regression with Regularization Model: $h_{\\theta}(x) = \\theta_0 + \\theta_1x + \\theta_2x^2 + \\theta_3x^3 + \\theta_4x^4$ Goal: $J(\\theta) = \\frac{1}{2m}\\sum_{i = 1}^m(h_\\theta(x^{(i)}) - y^{(i)})^2 + \\frac{\\lambda}{2m}\\sum_{j = 1}^n\\theta_j^2$ $J_{train}(\\theta) = \\frac{1}{2m_{train}}\\sum_{i = 1}^{m_{train}}(h_{\\theta}(x_{train}^{(i)}) - y_{train}^{(i)})^2$ $J_{cv}(\\theta) = \\frac{1}{2m_{cv}}\\sum_{i = 1}^{m_{cv}}(h_{\\theta}(x_{cv}^{(i)}) - y_{cv}^{(i)})^2$ $J_{test}(\\theta) = \\frac{1}{2m_{test}}\\sum_{i = 1}^{m_{test}}(h_{\\theta}(x_{test}^{(i)}) - y_{test}^{(i)})^2$ Chossing the parameter $\\lambda$ 1). Try $\\lambda = 0 \\rarr minJ(\\theta) \\rarr \\theta^{(1)} \\rarr J_{cv}(\\theta^{(1)})$ 2). Try $\\lambda = 0.01 \\rarr minJ(\\theta) \\rarr \\theta^{(2)} \\rarr J_{cv}(\\theta^{(2)})$ 3). Try $\\lambda = 0.02 \\rarr minJ(\\theta) \\rarr \\theta^{(3)} \\rarr J_{cv}(\\theta^{(3)})$ 4). Try $\\lambda = 0.04 \\rarr minJ(\\theta) \\rarr \\theta^{(4)} \\rarr J_{cv}(\\theta^{(4)})$ 5). Try $\\lambda = 0.08 \\rarr minJ(\\theta) \\rarr \\theta^{(5)} \\rarr J_{cv}(\\theta^{(5)})$ … 10). Try $\\lambda = 10 \\rarr minJ(\\theta) \\rarr \\theta^{(10)} \\rarr J_{cv}(\\theta^{(10)})$ Pick $\\theta^{(5)}$, Test Error: $J_{test}(\\theta^{(5)})$ Draw the “lambda - Error” plot. In this Plot draw the $J_{tra","date":"2020-12-18","objectID":"/machine-learning/:3:6","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Error Analysis ","date":"2020-12-18","objectID":"/machine-learning/:4:0","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Recommand Approach Start with a simple algorithm that you can implement quickly. Implement it and test it on Cross-Validation Set. Plot learning curves to decide if more Data, more Features, etc. Error Analysis: Manually examine the examples ( In Cross Validation Set ) that your algorithm made errors on. See if you spot any systematic trend in what type of examples it is making errors on. ","date":"2020-12-18","objectID":"/machine-learning/:4:1","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Error metrics for skewed classes Cancer classification example: Train logistic regression model $h_\\theta(x). ( y = 1 if cancer ) Find you got $1%$ error on test set Only $0.50%$ patients have cancer function y = predictCancer(x) y = 0; // ignore x! Because 99.5% Patients don't have cancer! return Precision / Recall 1 0 1 True positiv False positiv 0 False Negative True Negative Precision: Of all patients where we predicted $y = 1$, what fraction actually has cancer? True positives / predicted Positive = True positives / (True Pos + False Pos) Recall( Of all patients that actually have cancer, what fraction did we corrently detect as having cancer? ) True positives / actual Positives = True Positives / (True Pos + False Neg) Trading off precision and recall Logistic Regression: $0 \\leq h_\\theta(x) \\leq 1$ Predict 1 if $h_\\theta(x) \\geq 0.5$ Predict 0 if $h_\\theta(x) \\leq 0.5$ Suppose we want to predict $y = 1$ ( cancer ) only if very confident $\\rarr \\text{Higher Precision, lower Recall}$ Suppose we want to avoid missing too many cases of cancer ( avoid false Negatives ) $\\rarr \\text{Higher Recall, lower Precision}$ More generally, predict 1 if $h_\\theta(x) \\geq \\text{threshold}$ F Score How to compare Precision / Recall numbers? Precision (P) Recall (R) F Score Algorithm 1 0.5 0.4 0.444 Algorithm 2 0.7 0.1 0.175 Algorithm 3 0.02 1 0.0392 F Score: $2\\frac{PR}{P + R}$ ","date":"2020-12-18","objectID":"/machine-learning/:4:2","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Support Vector Machines ","date":"2020-12-18","objectID":"/machine-learning/:5:0","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Optimization objective Brief Review of Logistic Regression $h_\\theta(x) = \\frac{1}{1 + e^{-\\theta^Tx}}$ if $y = 1$, we want $h_\\theta(x) \\approx 1, \\theta^Tx \\gg 0$ if $y = 0$, we want $h_\\theta(x) \\approx 0, \\theta^Tx \\ll 0$ $J(\\theta) = -\\frac{1}{m}\\sum_{i = 1}^{m}[y^{(i)}log(h_\\theta(x^{(i)})) + (1 - y^{(i)})log(1 - h_\\theta(x^{(i)}))] + \\frac{\\lambda}{2m}\\sum_{j = 1}^{n}\\theta_j^2$ $-log\\frac{1}{1 + e^{-x}} \\rarr Cost_1(\\theta^Tx^{(i)})$ $-log(1 - \\frac{1}{1 + e^{-x}}) \\rarr Cost_0(\\theta^Tx^{(i)})$ Cost Function: We use a new function to replace $-log\\frac{1}{1 + e^{-x}} \\text{and} -log(1 - \\frac{1}{1 + e^{-x}})$. We name they as $Cost_1(\\theta^Tx^{(i)})\\text{and}Cost_0(\\theta^Tx^{(i)})$. Then the Cost Function in SVM is: $\\frac{1}{m}\\sum_{i = 1}^{m}[y^{(i)}Cost_1(\\theta^Tx^{(i)}) + (1 - y^{(i)})Cost_0(\\theta^Tx)] + \\frac{\\lambda}{2m}\\sum_{j = 1}^{n}\\theta_j^2$ The following Plot is the Picture of 2 new Functions: Our goal is to minimize the following Function: $min_\\theta C\\sum_{i = 1}^{m}[y^{(i)}Cost_1(\\theta^Tx^{(i)}) + (1 - y^{(i)})Cost_0(\\theta^Tx)] + \\frac{1}{2}\\sum_{j = 1}^{n}\\theta_j^2$ SVM Hypothesis: $h_\\theta(x) = \\begin{cases}1, \\theta^Tx \\geq 0\\\\0, \\theta^Tx \u003c 0\\end{cases}$ ","date":"2020-12-18","objectID":"/machine-learning/:5:1","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Large Margin Intuition Take a look at the Plot of the new Cost Functions: if $y = 1$, we want $\\theta^Tx \\geq 1$ if $y = 0$, we want $\\theta^Tx \\leq -1$ SVM Decision Boundary $min_\\theta C\\sum_{i = 1}^{m}[y^{(i)}Cost_1(\\theta^Tx^{(i)}) + (1 - y^{(i)})Cost_0(\\theta^Tx^{(i)})] + \\frac{1}{2}\\sum_{j = 1}^{n}\\theta_j^2 ( C = \\frac{1}{\\lambda} )$ Large C: lower Bias, higher Variance Small C: higher Bias, lower Variance In “Large Margin Boundary” we know, we just have to optimize the following function: $\\frac{1}{2}\\sum_{j = 1}^{n}\\theta_j^2$ ( Because the front part can be 0. ) ","date":"2020-12-18","objectID":"/machine-learning/:5:2","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Kernels Kernel Function Given x,: $f_i = similarity(x, l^{(i)}) = exp(-\\frac{||x - l^{(2)}||^2}{2\\sigma^2})$ Large $\\sigma^2$: Features $f_i$ vary very smmothly: Higher Bias, lower Variance Small $\\sigma^2$: Features $f_i$ vary very smmothly: lower Bias, higher Variance SVM with Kernels Where to get $l^{(1)}, l^{(2)}, l^{(3)} … ?$ Given $(x^{(1)}, y^{(1)}), (x^{(2)}, y^{(2)}), …, (x^{(m)}, y^{(m)})$ Choose $l^{(1)} = x^{(1)}, l^{(2)} = x^{(2)}, …, l^{(m)} = x^{(m)}$ Given $x$: $f_1 = similarity(x, l^{(1)})$ $f_2 = similarity(x, l^{(2)})$ … $f = \\begin{bmatrix}f_0\\\\f_1\\\\f_2\\\\…\\\\f_m\\end{bmatrix}, f_0 = 1$ For Training example $(x^{(i)}, y^{(i)}):$ $f_1^{(i)} = similarity(x^{(i)}, l^{(1)})$ $f_2^{(i)} = similarity(x^{(i)}, l^{(2)})$ $f_3^{(i)} = similarity(x^{(i)}, l^{(3)})$ … $f_m^{(i)} = similarity(x^{(i)}, l^{(m)})$ $f^{(x)} = \\begin{bmatrix}f_0^{(i)}\\\\f_1^{(i)}\\\\…\\\\f_m^{(i)}\\end{bmatrix}$ Predict $y = 1, \\text{if } \\theta^Tf \\geq 0$ Training: $min_\\theta C\\sum_{i = 1}^{m}[y^{(i)}Cost_1(\\theta^Tf^{(i)}) + (1 - y^{(i)})Cost_0(\\theta^Tf^{(i)})] + \\frac{1}{2}\\sum_{j = 1}^{n}\\theta_j^2$ ","date":"2020-12-18","objectID":"/machine-learning/:5:3","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Logistic Regression vs. SVMs n = number of Features, m = number of Training examples if n is large ( relative to m ): Use logistic Regression, or SVM without a kernel if n is small, m is intermediate: Use SVM with Gaussian Kernel if n is small, m is large: Create / Add more Features, then use logistic regression or SVM without a Kernel ","date":"2020-12-18","objectID":"/machine-learning/:5:4","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Unsupervised Learning ","date":"2020-12-18","objectID":"/machine-learning/:6:0","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Clustering K-Mean Algorithm Input: K ( Number of clusters ) Training Set ${x^{(1)}, x^{(2)}, …, x^{(m)}}$ $x^{(i)} \\isin \\R^n$ ( Drop $x_0 = 1$ convention ) Randomly initialize K cluster Centroids $\\mu_1, \\mu_2, …, \\mu_k\\isin\\R^n$ Repeat: // Cluster Assignment for i = 1 to m: c^(i) := index ( from 1 to K ) of Cluster Centroid closest to x^(i) // ||x^(i) - mu_k|| // Move Centroid for k = 1 to K: mu_k := average ( mean ) of points asssigned to cluster k // A vector in R^n In the code above $c^{(i)}$ means the index of cluster to which example $x^{(i)}$ is currently assigned. $\\mu_k\\ \\text{means the cluster centroid}\\ k (\\mu_k \\isin\\R^n)$ $\\mu{c^{(i)}}$ means the cluster centroid of cluster to which example $x^{(i)}$ has been assigned._ Optimization Objective of K-Mean: Distortion Function $J(c^{(1)}, …, c^{(m)}, \\mu_1, …, \\mu_k) = \\frac{1}{m}\\sum_{i = 1}^m||x^{(i)} - \\mu_{c^{(i)}}||^2$ Initialize K-Means Randomly pick K training examples Set $\\mu_1, …, \\mu_k$ equal to these K examples. for i = 1 to 100{ Randomly initialize K-means Run K-means, Get c^(1), ..., c^(m), mu^(1), ..., , mu^(K) Compute the distortion Function } Pick clustering that gave lowest distortion Function value. Choosing the number of clusters Alternative: Draw the “K - Distortion Function Value” plot. ( Elbow Method ) ","date":"2020-12-18","objectID":"/machine-learning/:6:1","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Dimentionality Reduction ","date":"2020-12-18","objectID":"/machine-learning/:7:0","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"PAC: Principal Component Analysis Reduce from 2-dimension to 1-dimension: Find a direction ( a vector $\\mu^{(1)} \\isin \\R^n$ ) onto which to project the data so as to minimize the projection error. Reduce from n-dimension to k-dimension: Find k vectors ( vectors $\\mu^{(1)}, …, \\mu^{(k)}$ ) onto which to project the data, so as to minimize the projection error. Reduce memory / disk needed to store data Speed up learning algorithm Bad use of PCA: To prevent overfitting. Instead, use regularization. PCA is not Linear Regression! ","date":"2020-12-18","objectID":"/machine-learning/:7:1","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Data Processing Training Set: $x^{(1)}, x^{(2)}, …, x^{(m)}$ Preprocessing ( Feature Scaling / Mean Normalization ) $\\mu_j = \\frac{1}{m}\\sum_{i = 1}^mx_j^{(i)}$ Replace each $x_j^{(i)}$ with $x_j - \\mu_j$ If different features have different scales, scale Features to have comparable range of values $x_j \\larr \\frac{x_j^{(i)} - \\mu_j}{s_j}$ ","date":"2020-12-18","objectID":"/machine-learning/:7:2","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"PCA algorithm Reduce data from n-dimensions to k-dimensions Compute “convariance matrix” $\\Sigma = \\frac{1}{m}\\sum_{i = 1}^{m}(x^{(i)})(x^{(i)})^T, \\Sigma \\isin \\R^{n\\times n}$ Compute the “eigenvectors” of $\\Sigma$: [U, S, V] = svd( Sigma ) // Singular Value Decomposition; Uredece = U(:, 1:k); z = Ureduce' * x; From the formular above we get: $U = \\begin{bmatrix}|\u0026|\u0026…\u0026|\\\\u^{(1)}\u0026u^{(2)}\u0026…\u0026u^{(n)}\\\\|\u0026|\u0026…\u0026|\\end{bmatrix} \\isin \\R^{n\\times n}$ Then we use the first k columns in the Matrix: $z^{(i)} = U_{reduce}^Tx^{(i)} = \\begin{bmatrix}|\u0026|\u0026…\u0026|\\\\u^{(1)}\u0026u^{(2)}\u0026…\u0026u^{(k)}\\\\|\u0026|\u0026…\u0026|\\end{bmatrix}^Tx^{(i)} = \\begin{bmatrix}-\u0026(u^{(1)})^T\u0026-\\\\…\u0026…\u0026…\\\\-\u0026(u^{(k)})^T\u0026-\\end{bmatrix}x^{(i)} \\isin \\R^{k\\times 1}$ ","date":"2020-12-18","objectID":"/machine-learning/:7:3","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Choosing k ( number of principle components ) Average squaied projection error: $\\frac{1}{m}\\sum_{i = 1}^m||x^{(i)} - x_{approx}^{(i)}||^2$ Total variation in the data: $\\frac{1}{m}\\sum_{i = 1}^{m}||x^{(i)}||^2$ Typically, choose k to be smallest value so that: $\\frac{\\frac{1}{m}\\sum_{i = 1}^m||x^{(i)} - x^{(i)}_{approx}||^2}{\\frac{1}{m}\\sum_{i = 1}^{m}||x^{(i)}||^2} \\leq 0.01$ “99% of variances is retained” Algorithm: Try PCA with k = 1 Compute $U_{reduce}, z^{(1)}, z^{(2)}, …, z^{(m)}, x_{approx}^{(1)}, …, x^{(m)}_{approx}$ Check if $\\frac{\\frac{1}{m}\\sum_{i = 1}^m||x^{(i)} - x^{(i)}_{approx}||^2}{\\frac{1}{m}\\sum_{i = 1}^{m}||x^{(i)}||^2} \\leq 0.01$ [U, S, V] = svd( Sigma ) For given k, $\\frac{\\frac{1}{m}\\sum_{i = 1}^m||x^{(i)} - x^{(i)}_{approx}||^2}{\\frac{1}{m}\\sum_{i = 1}^{m}||x^{(i)}||^2} = 1 - \\frac{\\sum_{i = 1}^ks_{ii}}{\\sum_{i = 1}^{n}s_{ii}} \\rarr \\frac{\\sum_{i = 1}^ks_{ii}}{\\sum_{i = 1}^{n}s_{ii}} \\geq 0.99$ Pick k, that satisfies $\\frac{\\sum_{i = 1}^ks_{ii}}{\\sum_{i = 1}^{n}s_{ii}} \\geq 0.99$ ","date":"2020-12-18","objectID":"/machine-learning/:7:4","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Reconstruction from compressed representation $X_{approx} = U_{reduce} \\times z$ ","date":"2020-12-18","objectID":"/machine-learning/:7:5","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Design of ML system with PCA Get Training Set Run PCA to reduce $x^{(i)}$ in dimension to get $z^{(i)}$ Train logistic regression on ${(z^{(1)}, y^{(1)}), …, (z^{(m)}, y^{(m)})}$ Test on test set: Map $x_{test}^{(i)}\\ \\text{to}\\ z_{test}^{(i)}$. Run $h_\\theta(z)$ on ${(z_{test}^{(1)}, y_{test}^{(1)}), …, (z_{test}^{(m)}, y_{test}^{(m)})}$ Before implementing PCA, first try running whatever you want to do with original / raw data $x^{(i)}$. Only if that doesn’t do what you want, then implement PCA and consider using $z^{(i)}$ ","date":"2020-12-18","objectID":"/machine-learning/:7:6","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Anomoly Detection ","date":"2020-12-18","objectID":"/machine-learning/:8:0","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Example: Fraud Detection $x^{(i)}$ = features of user i’s activities Model $p(x)$ from data Identify unusual users by checking which have $p(x) \u003c \\epsilon$ ","date":"2020-12-18","objectID":"/machine-learning/:8:1","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Gaussian Distribution Say $x \\isin \\R$. If x is a disatributed Gaussian with mean $\\mu$, variance $\\sigma^2$. $p(x; \\mu, \\sigma^2) = \\frac{1}{\\sqrt{2\\pi}\\sigma}exp^{(-\\frac{(x - \\mu)^2}{2\\sigma^2})}$. Here $\\sigma$ is the standard deviation. As for “Parameter estimation”… $\\mu = \\frac{1}{m}\\sum_{i = 1}^mx^{(i)}$ $\\sigma^2 = \\frac{1}{m}\\sum_{i = 1}^m(x^{(i)} - \\mu)^2$ ","date":"2020-12-18","objectID":"/machine-learning/:8:2","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Algorithm Training Set ${x^{(1)}, …, x^{(m)}}$ Each Example is $x \\isin \\R^n$ Chosse features $x_i$ that you think might be indicative of anomalous examples. Fit parameters $\\mu_1, …, \\mu_n, \\sigma_1^2, …, \\sigma_n^2$ $\\mu = \\frac{1}{m}\\sum_{i = 1}^mx^{(i)}$ $\\sigma^2 = \\frac{1}{m}\\sum_{i = 1}^m(x^{(i)} - \\mu)^2$ Given new example x, compute $p(x)$ $p(x) = \\prod_{j = 1}^np(x_j;\\mu_j, \\sigma_j^2) = \\prod_{j = 1}^n\\frac{1}{\\sqrt{2\\pi}\\sigma}exp^{(-\\frac{(x - \\mu)^2}{2\\sigma^2})}$ Anomaly if $p(x) \u003c \\epsilon$ Evaluation Fit model $p(x)$ on training set ${x^{(1)}, …, x^{(m)}}$ On a Cross Validation / Test example, predict $y = \\begin{cases}1,\\ p(x) \u003c \\epsilon\\ \\text{(anomaly)}\\\\0,\\ p(x) \\geq \\epsilon\\ \\text{(normal)}\\end{cases}$ Possible evaluation metrics: True positive, false positive, false negative, true negative Precision / Recall F-Score Can also use the Cross Validation Set to choose parameter $\\epsilon$ ","date":"2020-12-18","objectID":"/machine-learning/:8:3","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Anomoly Detection vs. Supervised Learning Anomoly Detection Supervised Learning Very small number of positiv examples but large number of negative examples Large number of positive and negative examples Many different types of anomalies. Hard for any algorithm to learn from positive examples what the anomalies looks like Enough positive examples for algorithm to get a sense of what positive examples are like Future anomalies may look nothing like any of the anomalous examples we’ve seen so far Future positive examples likely to be similar to ones in training set ","date":"2020-12-18","objectID":"/machine-learning/:8:4","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Error Analysis for anomaly detection Want $p(x)$ large for normal examples x $p(x)$ small for anomalous examples x Most commen Problem: $p(x)$ is comparable ( say, both large ) for normal and anomalous examples. ","date":"2020-12-18","objectID":"/machine-learning/:8:5","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Multivariance Gaussian Distribution $x \\isin \\R^n$, don’t model $p(x_1), p(x_2)$, …, etc. separately. Instead, model $p(x)$ all in one go. Parameters: $\\mu\\isin\\R^n, \\Sigma \\isin \\R^{n\\times n}$, the “convariance matrix” $p(x; \\mu, \\Sigma) = \\frac{1}{(2\\pi)^{(\\frac{n}{2})}|\\Sigma|^\\frac{1}{2}}exp(=\\frac{1}{2}(x - \\mu)^T\\Sigma^{-1}(x - \\mu))$ ","date":"2020-12-18","objectID":"/machine-learning/:8:6","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Recommander Systems ","date":"2020-12-18","objectID":"/machine-learning/:9:0","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Problem Formulation Example: Predicting movie ratings Movie Alice(1) Bob(2) Carol(3) Dave(4) Love at last 5 5 0 0 Romance forever 5 ? ? 0 Cute Puppies of love ? 4 0 ? Nonstop car cashes 0 0 5 4 Swords vs. karate 0 0 5 ? $n_u$: no.users $n_m$: no.movies $r(i, j) = 1$: if user $j$ has rated movie $i$ $y^{(i,j)} \\isin [0,5]$: rating given by user $j$ to movie $i$ ( defined only if $r(i, j) = 1$ ) ","date":"2020-12-18","objectID":"/machine-learning/:9:1","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Contnet-based recommendations Movie Alice(1) Bob(2) Carol(3) Dave(4) $x_1$(romance) $x_2$(action) Love at last 5 5 0 0 0.9 0 Romance forever 5 ? ? 0 1.0 0.01 Cute Puppies of love ? 4 0 ? 0.99 0 Nonstop car cashes 0 0 5 4 0.1 1.0 Swords vs. karate 0 0 5 ? 0 0.9 For each user j, learn a parameter $\\theta^{(j)} \\isin \\R^3$. Predict user j as rating movie i with $(\\theta^{(j)})^Tx^{(i)}$ stars. ( $x_0 = 1$ ) $\\theta^{(j)} =$ parameter vector for user $j$ $x^{(i)} =$ feature vector for movie $i$ For user j, movie i, predicting rating: $(\\theta^{(j)})^Tx^{(i)}$ $m^{(j)} =$ no.of movies rated by user $j$ To learn $\\theta^{(j)}$: $min_{\\theta^{(j)}}\\frac{1}{2m^{(j)}}\\sum_{i:r(i, j) = 1}((\\theta^{(j)})^T(x^{(i)} - y^{(i, j)})^2 + \\frac{\\lambda}{2m^{(j)}}\\sum_{k = 1}^{n}(\\theta_k^{(j)})^2$ $\\rarr min_{\\theta^{(j)}}\\frac{1}{2}\\sum_{i:r(i, j) = 1}((\\theta^{(j)})^T(x^{(i)} - y^{(i, j)})^2 + \\frac{\\lambda}{2}\\sum_{k = 1}^{n}(\\theta_k^{(j)})^2$ To learn $\\theta^{(1)}, \\theta^{(2)}, …, \\theta^{(n_u)}$: $min_{\\theta^{(1)}, \\theta^{(2)}, …, \\theta^{(n_u)}}\\frac{1}{2}\\sum_{j = 1}^{n_u}\\sum_{i:r(i, j) = 1}((\\theta^{(j)})^T(x^{(i)} - y^{(i, j)})^2 + \\frac{\\lambda}{2}\\sum_{j = 1}^{n_u}\\sum_{k = 1}^{n}(\\theta_k^{(j)})^2$ Optimization Algorithm $min_{\\theta^{(1)}, \\theta^{(2)}, …, \\theta^{(n_u)}}\\frac{1}{2}\\sum_{j = 1}^{n_u}\\sum_{i:r(i, j) = 1}((\\theta^{(j)})^T(x^{(i)} - y^{(i, j)})^2 + \\frac{\\lambda}{2}\\sum_{j = 1}^{n_u}\\sum_{k = 1}^{n}(\\theta_k^{(j)})^2$ Gradient Descent update: $\\theta_k^{(j)} \\coloneqq \\theta_k^{(j)} - \\alpha\\sum_{i:r(i, j) = 1}((\\theta^{(j)})^Tx^{(i)} - y^{(i, j)})x_k^{(i)}$ ( for $k = 0$ ) $\\theta_k^{(j)} \\coloneqq \\theta_k^{(j)} - \\alpha(\\sum_{i:r(i, j) = 1}((\\theta^{(j)})^Tx^{(i)} - y^{(i, j)})x_k^{(i)} + \\lambda\\theta_k^{(j)})$ ( for $k \\not = 0$ ) ","date":"2020-12-18","objectID":"/machine-learning/:9:2","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Collaborative Filtering Optimization Algorithm Given $\\theta^{(1)}, \\theta^{(2)}, …, \\theta^{(n_u)}$, to learn $x^{(i)}$: $min_{x^{(i)}}\\frac{1}{2}\\sum_{j = 1}^{n_u}\\sum_{i:r(i, j) = 1}((\\theta^{(j)})^T(x^{(i)} - y^{(i, j)})^2 + \\frac{\\lambda}{2}\\sum_{k = 1}^{n}(x_k^{(i)})^2$ Given $\\theta^{(1)}, \\theta^{(2)}, …, \\theta^{(n_u)}$, to learn $x^{(1)}, …, x^{(n_u)}$: $min_{x^{(1)}, x^{(2)}, …, x^{(n_m)}}\\frac{1}{2}\\sum_{i = 1}^{n_m}\\sum_{i:r(i, j) = 1}((\\theta^{(j)})^T(x^{(i)} - y^{(i, j)})^2 + \\frac{\\lambda}{2}\\sum_{i = 1}^{n_m}\\sum_{k = 1}^{n}(x_k^{(i)})^2$ Collaborative Filtering Given $x^{(1)}, x^{(2)}, …, x^{(n_m)}$ (and movie ratings), can estimate $\\theta^{(1)}, \\theta^{(2)}, …, \\theta^{(n_u)}$ Given $\\theta^{(1)}, \\theta^{(2)}, …, \\theta^{(n_u)}$, can estimate $x^{(1)}, x^{(2)}, …, x^{(n_m)}$ Guess $\\theta \\rarr x \\rarr \\theta \\rarr x \\rarr \\theta \\rarr x \\rarr …$ Collaborative Filtering Algorithm Collaborative flitering optimization objective Given $x^{(1)}, x^{(2)}, …, x^{(n_m)}$, estimate $\\theta^{(1)}, \\theta^{(2)}, …, \\theta^{(n_u)}$ $min_{\\theta^{(1)}, \\theta^{(2)}, …, \\theta^{(n_u)}}\\frac{1}{2}\\sum_{j = 1}^{n_u}\\sum_{i:r(i, j) = 1}((\\theta^{(j)})^T(x^{(i)} - y^{(i, j)})^2 + \\frac{\\lambda}{2}\\sum_{j = 1}^{n_u}\\sum_{k = 1}^{n}(\\theta_k^{(j)})^2$ Given $\\theta^{(1)}, \\theta^{(2)}, …, \\theta^{(n_u)}$, estimate $x^{(1)}, x^{(2)}, …, x^{(n_m)}$ $min_{x^{(1)}, x^{(2)}, …, x^{(n_m)}}\\frac{1}{2}\\sum_{i = 1}^{n_m}\\sum_{i:r(i, j) = 1}((\\theta^{(j)})^T(x^{(i)} - y^{(i, j)})^2 + \\frac{\\lambda}{2}\\sum_{i = 1}^{n_m}\\sum_{k = 1}^{n}(x_k^{(i)})^2$ $min_{(x^{(1)}, x^{(2)}, …, x^{(n_m)}, \\theta^{(1)}, \\theta^{(2)}, …, \\theta^{(n_u)})}\\frac{1}{2}\\sum_{(i, j):r(i, j) = 1}((\\theta^{(j)})^T(x^{(i)} - y^{(i, j)})^2 + \\frac{\\lambda}{2}\\sum_{i = 1}^{n_m}\\sum_{k = 1}^{n}(x_k^{(i)})^2 + \\frac{\\lambda}{2}\\sum_{j = 1}^{n_u}\\sum_{k = 1}^{n}(\\theta_k^{(j)})^2$ Collaborative flitering Algorithm Initialize $x^{(1)}, x^{(2)}, …, x^{(n_m)}, \\theta^{(1)}, \\theta^{(2)}, …, \\theta^{(n_u)}$ to small random values Minimize $J(x^{(1)}, x^{(2)}, …, x^{(n_m)}, \\theta^{(1)}, \\theta^{(2)}, …, \\theta^{(n_u)})$ using gradient descent ( or advanced optimization algorithm ). E.g. For every $j = 1, …, n_u, i = 1, …. n_m:$ $x_k^{(i)} \\coloneqq x_k^{(i)} - \\alpha(\\sum_{j:r(i, j) = 1}((\\theta^{(j)})^T(x^{(i)} - y^{(i, j)}))\\theta_k^{(j)} + \\lambda x_k^{(i)})$ $\\theta_k^{(j)}\\coloneqq\\theta_k^{(j)} - \\alpha(\\sum_{i:r(i, j) = 1}((\\theta^{(j)})^T(x^{(i)} - y^{(i, j)}))\\theta_k^{(j)} + \\lambda \\theta_k^{(j)})$ For a user with parameters $\\theta$ and a movie with (learned) features $x$, predict a star rating $\\theta^Tx$. Vectorization: Low rank matrix factorization Movie Alice(1) Bob(2) Carol(3) Dave(4) Love at last 5 5 0 0 Romance forever 5 ? ? 0 Cute Puppies of love ? 4 0 ? Nonstop car cashes 0 0 5 4 Swords vs. karate 0 0 5 ? $Y = \\begin{bmatrix}5\u00265\u00260\u00260\u0026?\\\\5\u0026?\u0026?\u00260\u0026?\\\\?\u00264\u00260\u0026?\u0026?\\\\0\u00260\u00265\u00264\u0026?\\\\0\u00260\u00265\u00260\u0026?\\end{bmatrix}$ Predicted ratings ($X\\Theta^T, (i, j) = (\\theta^{(j)})^T(x^{(i)})$): $\\begin{bmatrix}(\\theta^{(1)})^T(x^{(1)})\u0026(\\theta^{(2)})^T(x^{(1)})\u0026…\u0026(\\theta^{(n_u)})^T(x^{(1)})\\\\(\\theta^{(1)})^T(x^{(2)})\u0026(\\theta^{(2)})^T(x^{(2)})\u0026…\u0026(\\theta^{(n_u)})^T(x^{(2)})\\\\…\u0026…\u0026…\u0026…\u0026\\\\(\\theta^{(1)})^T(x^{(n_m)})\u0026(\\theta^{(2)})^T(x^{(n_m)})\u0026…\u0026(\\theta^{(n_u)})^T(x^{(n_m)})\\end{bmatrix}$ $X = \\begin{bmatrix}-\u0026(x^{(1)})^T\u0026-\\\\-\u0026(x^{(2)})^T\u0026-\\\\…\u0026…\u0026…\\\\-\u0026(x^{(n_m)})^T\u0026-\\\\\\end{bmatrix}$ $\\Theta = \\begin{bmatrix}-\u0026(\\theta^{(1)})^T\u0026-\\\\-\u0026(\\theta^{(2)})^T\u0026-\\\\…\u0026…\u0026…\\\\-\u0026(\\theta^{(n_m)})^T\u0026-\\\\\\end{bmatrix}$ Finding related movies For each product $i$, we learn a feature vector $x^{(i)}\\isin \\R^n$. How to find movies $j$ related to movie $i$? Find movies with the smallest $||x^{(i)} - x^{(j)}||$ Mean Normalization Movie Alice(1) Bob(2) Carol(3) Dave(4) Eve(5) Love at last 5 5 0 0 ? Romance forever 5 ? ? 0 ? Cute Puppies of love ? 4 0 ? ? Nonstop car cashes 0 0 5 4 ? Swords vs. karate 0 0 5 ? ? $Y = \\begin{bmatrix}5\u00265\u00260\u00260\u0026?\\\\5\u0026?\u0026?\u00260\u0026?\\\\?\u00264\u00260\u0026?\u0026?\\\\0\u00260\u00265\u00264\u0026?\\\\0\u00260\u00265\u00260\u0026?\\end{bmatrix}$ $\\mu = \\begin{bmatrix}2.5\\","date":"2020-12-18","objectID":"/machine-learning/:9:3","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Learning with large datasets ","date":"2020-12-18","objectID":"/machine-learning/:10:0","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Stochastic gradient descent $Cost(\\theta, (x^{(i)}, y^{(i)}) = \\frac{1}{2}(h_\\theta(x^{(i)}) - y^{(i)})^2$ $J_{train}(\\theta) = \\frac{1}{m}\\sum_{i = 1}^mcost(\\theta, (x^{(i)}, y^{(i)})$ Randomly shuffle training examples, repeat $\\theta_j\\coloneqq\\theta_j - \\alpha(h_\\theta(x^{(i)}) - y^{(i)})x^{(i)}$ ","date":"2020-12-18","objectID":"/machine-learning/:10:1","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Mini-batch gradient descent Batch gradient descent: Use all m examples in each iteration Stochastic gradient descent: Use 1 example in each iteration Mini-batch gradient descent: Use b examples in each iteration ","date":"2020-12-18","objectID":"/machine-learning/:10:2","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"Convergence Batch gradient descent Plot $J_{train}(\\theta)$ as a function of the number of iterations of gradient descent. Stochastic gradient descent: During learning, compute $cost(\\theta, (x^{(i)}, y^{(i)}))$ before updating $\\theta$ using $(x^{(i)}, y^{(i)})$. Every 1000 iterations(say), plot $cost(\\theta, (x^{(i)}, y^{(i)}))$ averaged over the last 1000 examples processed by algorithm. ","date":"2020-12-18","objectID":"/machine-learning/:10:3","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":["Learn"],"content":"At the End… Thank you, Andrew Ng! ","date":"2020-12-18","objectID":"/machine-learning/:11:0","tags":["AI"],"title":"Machine Learning","uri":"/machine-learning/"},{"categories":null,"content":"About Me ","date":"2020-12-18","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Basic Infos Name: Dai Jiabin Birthday: 30.04.1997 Nation: China ","date":"2020-12-18","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Contact Mobile ( Germany ): TURFMU1qSXhOREk1TVRBNENnPT0K E-Mail: YTJWamFHOTFMbVJoYVVCbmJXRnBiQzVqYjIwSwo= p.S: run echo \u003cString above\u003e | base 64 -d| base 64 -d to get the Phone Number and the E-Mail Address. ","date":"2020-12-18","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Academic Background 08.2015 - 06.2019 Bachelor in Xidian University, China, majored in Computer Science and Technology GPA: 3.6 Graduate Thesis: Design and Realize the CAPTCHA Recognization System based on Convolutional Neural Networks 10.2019 - 07.2020 Language ( German ) Learning in Germany, lectures provided by TUDIAS 10.2020 - 04.2023 Master in Dresden University of Technology, Germany, majored in Informatik ","date":"2020-12-18","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Awarded Status ","date":"2020-12-18","objectID":"/about/:4:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Abilities Language Field English CET4 576 CET6 551 German, GER C1.1 - C1.2 French Russian Spanish Italian Japanese Icelandic Programm Field Languages I’ve learned: Applications \u0026 Enviroments: Certificates on Coursera: Programm written by myself Social Field Other Field ( Doesn’t achieve yet ) ACCA CTCSOL ","date":"2020-12-18","objectID":"/about/:5:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Lecture 1 ","date":"2020-12-18","objectID":"/nodejs/:0:0","tags":["NodeJS"],"title":"NodeJS","uri":"/nodejs/"},{"categories":null,"content":"What is NodeJS? Node.js is a JavaScript runtime built on Chrome’s V8 Node.js uses an event-driven, non-blocking I/O model Blocking: When I/O processing, process waits until I/O finishes. Non-blocking: When I/o processing, process doesn’t wait. Event-driven: i.g., Click event. ","date":"2020-12-18","objectID":"/nodejs/:1:0","tags":["NodeJS"],"title":"NodeJS","uri":"/nodejs/"},{"categories":null,"content":"Advantages of NodeJS Deals well with High Concurrency and I/O intensiv ","date":"2020-12-18","objectID":"/nodejs/:2:0","tags":["NodeJS"],"title":"NodeJS","uri":"/nodejs/"},{"categories":null,"content":"CPU Intensiv vs. I/O Intensiv CPU Intensiv: compress, decompress, encrpt, descrypt I/O Intensiv: Operations on File, Network and Database, which are offen used by Web ( Reading Static Resources, Operate Database, Render). ","date":"2020-12-18","objectID":"/nodejs/:3:0","tags":["NodeJS"],"title":"NodeJS","uri":"/nodejs/"},{"categories":null,"content":"How to deal with High Concurrency Increase Servers Increase the numbers of CPU-Cores And… NodeJS deals well with high Concurrency and I/O intensiv. ","date":"2020-12-18","objectID":"/nodejs/:4:0","tags":["NodeJS"],"title":"NodeJS","uri":"/nodejs/"},{"categories":null,"content":"NodeJS working Model Lecture 2 ","date":"2020-12-18","objectID":"/nodejs/:5:0","tags":["NodeJS"],"title":"NodeJS","uri":"/nodejs/"},{"categories":null,"content":"CommonJS, global and process CommonJS: Each file is a module, and has its own field. Inner the module, the parameter “module” represents module itself. Module.exports represents the API of module. modules.exports.\u003cVariable/Function\u003e = \u003cRename\u003e Rules of require() support extensions of js, json and node. Without path build-in Module or other third modules in node_modules will be used. Characters of require() In the 1st load module will be executed, and then stores in cache. When a module loaded repeatly, output the executed part only, instead of the unexecuted part. module.exports.test = 'A'; const modB = require('./05_modB'); console.log('modA: ', modB.test); module.exports.test = 'AA'; module.exports.test = 'B'; const modA = require('./05_modA'); console.log('modB: ', modA.test); module.exports.test = 'BB'; ","date":"2020-12-18","objectID":"/nodejs/:6:0","tags":["NodeJS"],"title":"NodeJS","uri":"/nodejs/"},{"categories":["Language"],"content":"德福考试论据汇总——写作 Aber jede Medaille hat auch Kehrseite. ","date":"2020-07-15","objectID":"/testdaf-reference/:0:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"一、在德大学生应选择何种工作(大学生兼职) Pro: 通过一份与专业相关的兼职学生可以积累职业经验，以此他们可以在以后的职场上更好地维持。 Durch einen fachbezogenen Job können die Studenten Berufserfahrungen sammeln, mit denen sie sich später auf dem Arbeitsmarkt besser behaupten können. 在做与专业相关的兼职工作的同时人不仅可以获得(erzielen)更好的收入(Gehalt)，也积累很多必将(sicherlich)使他在职场上的职业前景更加美好的经验。 Bei einem fachbezogenen Job erzielt man nicht nur ein besseres Gehalt, sondern man sammelt viele Erfahrungen, die sicherlich seine Berufsaussicht auf dem Arbeitsmarkt verbessert. 学业一直是学生的核心工作(im Mittelpunkt stehen)。在兼职工作中，他们也应该一直思考：他们应该如何将所学的东西(Gelernte)在实习中得以转化——这仅实现在专业相关的工作。 Das Studium steht immer im Mittelpunkt für die Studenten. Auch beim Nebenjob sollen sie ständig daran denken, wie sie das Gelernte in der Praxis umsetzen sollen. Und dies erfolgt nur bei einem fachbezogenen Job. 专业相关的工作也是学业与实习的连接。许多在学习过程中获得的知识，将会在专业相关的工作中得以应用。而且专业知识也将会通过在这类工作中所积累的经验而得以补充(ergänzen)。 Ein fachbezogner Job ist auch eine Verbindung zwischen der Praxis und dem Studium. Vieles, was man sich während des Studiums erworben hat, wird in einem fachbezogenen Job angewandt. Und die Fachkenntnisse werden durch gesammelte Erfahrungen bei solchen Jobs ergänzt. Übergang: 做兼职工作的意图或多或少都折射(widerspiegeln)了资产独立的意愿。但此外(hinaus)他们应该思考全局(Tellerrand)。 Die Absicht, einen Ferienjob zu machen, spiegelt mehr oder weniger den Wunsch nach finanzieller Unabhängigkeit wider. Aber Sie sollen über den Tellerrand hinaus denken. Kontra: 尽管一份简单的工作很容易获得且执行，但是人为此必须花费(aufwenden)许多时间。因此它并不值得(sich lohnen)。 Ein einfacher Job ist zwar leicht zu bekommen und durchzuführen, aber dafür muss man viel Zeit aufwenden. Deswegen lohnt es sich gar nicht. ","date":"2020-07-15","objectID":"/testdaf-reference/:1:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"二、SMS(现代媒体作用) Pro: SMS使得人与人之间的交流变得简单。人们可以随时随地与其他人交换(austauschen)信息。实际在会议(Sitzung)上人们不允许打电话，否则的话(Sonst)会议一定会被打断。通过SMS的帮助人可以在不打扰其他人的情况下获得重要的消息。 SMS erleichtert die Kommunikation zwischen den Menschen. Man kann jeder Zeit und überall Informationen mit anderen austauschen. In Sitzungen darf man eigentlich nicht telefonieren. Sonst werden die Sitzungen ständig gestört. Mit Hilfe von SMS bekommt man wichtige Informationen, ohne Andere zu stören. 人可以通过SMS得到细节的路径描述。当人在一个陌生的地方寻找特定的地址时，需要一份详尽的(ausführlich)路程描述。 但在路途中(unterwegs)人不可以写东西。在SMS的帮助下一切都将会展现在显示屏上，以此人可以轻松的找到方向。 Man bekommt per SMS eine detaillierte Wegbeschreibung. Wenn man an einem fremden Ort bestimmite Adresse sucht, benötigt man eine ausführliche Wegbeschreibung. Aber unterwegs kann man nichts aufschreiben. Mit Hilfe von SMS wird alles auf dem Display dargestellt, so dass man sich leicht orientieren kann. SMS也有聊天的作用。伴着重要的信息人们也会发送一些笑话或简短的历史。当一个人孤身一人感到无聊的时候，他就可以阅读之前存储的有趣的SMS并转发(weiterleiten)。以此越来越多的人在日常生活中感受欢乐。正是这些社会性的功能对SMS的使用及扩散尤为重要。 SMS hat eine Unterhaltungsfunktion. Neben wichtigen Informationen verschicken Menschen auch Witze oder kurze Geschichte. Wenn man allein ist und sich langweilig fühlt, kann man die vorher gespeicherten interessanten SMS lesen und weiterleiten. Dabei erleben immer mehr Menschen Freude im Alltag. Genau diese soziale Funktion ist besonders wichtig für die Nutzung und Verbreitung von SMS. 这种新的交流对绩效的提高有所贡献。在SMS中句子将写(verfassen)为更为短小的形式。这有一个优点，人可以快速地获得(vermitteln)观点或从他人得到观点。阅读时间将会显著缩短。在如今快速的(schnellebig)时代人有许多需要阅读的东西，并因此没有内在损失(Verlust)的短句十分的重要。 Die neue Kommunikation trägt zur Leistungserhöhung bei. In SMS werden die Sätze in kurzer Form verfasst. Dies hat einen Vorteil, dass man ganz schnell die Meinungen vermittelt oder die Meinungen von anderen bekommt. Die Lesezeit wird wesentlich verkürzt. In dem heutigen schnellebigen Zeitalter hat man viel zu lesen und deshalb sind kurze Sätze ohne inhaltlichen Verlust ganz wichtig. Kontra: 尽管有这种可能性：青少年在SMS过度使用的过程中遇到成瘾(Süchtigkeit)的问题，但这仅发生在当父母和学校完全不管控青少年为SMS所使用(verwenden)的时间的情况下。 Es besteht zwar die Möglichkeit, dass die Jugendlichen bei der exzessiven Nutzung von SMS in Süchtigkeit geraten. Aber dies passiert nur dann, wenn die Eltern und die Schule die Zeit, die die Jugendlichen für SMS verwenden, überhaupt nicht kontrollieren. 人只需要注意年轻人不应该过久地玩弄手机，因为这事关健康的眼睛。 Man braucht nur darauf zu achten, dass junge Menschen nicht zu lange mit dem Handy beschäftigt sein sollen. Denn es geht um die gesunden Augen. 在SMS中的表达并非一直是语法正确的。 Im SMS gibt es nicht immer richtige Ausdrücke. ","date":"2020-07-15","objectID":"/testdaf-reference/:2:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"三、电子游戏与儿童教育(现代媒体对青少年的影响) Pro: 在管控下青年人可以节省花费在电脑游戏上的时间。 Die Jugendlichen können durch die Kontrolle über Computerspiele Zeit sparen. 管控将在儿童和青少年地成长过程中发挥积极的作用——他们可以获得正确的方向。他们主要的任务是通过学习持续深造并为出色的未来做准备。没有管控许多青少年将会陷入上瘾以及依赖性。 Die Kontrolle auswirkt sich possitiv auf die Entwicklung der Kinder und Jugendlichen. Sie können richtige Orientierung bekommen. Ihre Hauptaufgabe besteht darin, dass sie sich durchs Lernen immer weiter qualifizieren und sich auf blendende Zukunft vorbereiten. Ohne Kontrolle werden viele junge Menschen in Sucht und Abhängigkeit verfallen. 管控使儿童和青少年地良好习惯成为可能。他们应该在日常生活中设计一个正确的计划，以充实生活。他们应该明白，他们的生活不仅仅只由电脑和互联网组成。 Die Kontrolle kann den Kindern und Jugendlichen gute Gewohnheit ermöglichen. Sie sollen im Alltag einen richtigen Plan schmieden, um das Leben zu bereichern. Sie sollten wissen, dass ihr Leben nicht nur aus Computer und Internet besteht. 这与健康有关。一方面管控对青少年的物理健康的改良有所贡献。当人在电脑面前坐太久，不仅仅是眼睛，脊椎也会被损伤。年轻人应该按时睡觉，而不是忙于电脑游戏或聊天直到深夜。另一方面管控也关照青年人的心理健康。因为儿童和青少年可以在有害信息前被保护。许多关于暴力、犯罪、诈骗和性将会损伤年轻人的心理健康。 Es geht um Gesundheit. Zum einen trägt die Kontrolle zur Verbesserung physiologischer Gesundheit der Jugendlichen bei. Wenn man zu lange vor dem Computer sitzt, werden nicht nur Augen, sondern auch Wirbelsäulen geschädigt. Die jungen Leute sollen pünktlich ins Bett gehen, statt Computerspiele oder Chat bis in die Nacht zu treiben. Zum anderen sorgt die Kontrolle auch die psychische Gesundheit der Jugendlichen. Denn die Kinder und Jugendlichen können vor schädlichen Informationen geschützt werden. Viele Informationen über Gewalt, Kriminalität, Betrüge und Sex werden die psychische Gesundheit der jungen Leute beeinträchtigen. Kontra: 短时期内青少年得到多面且丰富的信息会被阻碍。 Kurzfristig können die Jugendlichen verhindert werden, an vielfältige und reichliche Informationen zu kommen. 儿童和青少年失去了自我控制的机会。独自一人的时候自律不会自己出现。当学校和父母给学生和儿童展示互联网上的何种内容是对儿童、青少年合适的以及如何计划他们的时间，这再好不过了。 Kinder und Jugendlichen verlieren die Chance, sich selbst zu kontrollieren. Die Selbstdisziplin kommt nicht automatisch von allein. Es wäre besser, wenn Schulen und Eltern den Schülern und den Kindern zeigen, welche Inhalte im Internet für Kinder und Jugendliche geeignet sind und wie sie ihre Zeit planen können. 当儿童们仅仅使用传统的媒体学习是很无聊的。因为知识在互联网上会连续的更新。除此之外互联网上的知识比在书上更加直观。许多电脑游戏也须要战略以及对游戏的思考。由此年轻人将自己明白，有意义地使用电脑和互联网。 Es ist langweilig für Kinder, wenn sie nur mit traditionallen Medien lernen. Denn das Wissen im Internet wird ständig aktualisiert. Außerdem ist das Wissen im Internet viel anschaulicher als das in Büchern. Auch viele Computerspiele verlangen die Strategie und das Nachdenken von den Spielen. Drüber hinaus werden junge Menschen selbst darauf kommen, Computer und Internet sinnvoll zu nutzen. 对生活在信息时代的人来说现代媒体的使用是最重要的能力之一。如今不擅长使用电脑和互联网的人在学业以及求职过程中注定有着不小的困难。 Der Umgang mit modernen Medien ist eine der wichtigsten Kompetenze für die Menschen im Informationszeitalter. Wer heutzutage ungeschickt mit Computer und Internet umgeht, hat bestimmt große schwierigkeit beim Studium und bei der Suche nach einer Arbeit. ","date":"2020-07-15","objectID":"/testdaf-reference/:3:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"四、家庭办公(现代工作方式，人与人之间的联系， 现代媒体的应用) Pro: 人必须明白，鉴于强烈的交通密度人不得不在去工作的路上牺牲更多的时间，当所有人每天同时开车前去工作的时候。交通堵塞所浪费的时间，至少是人在家里为一通不情愿的电话所花费时间的三倍。更不用说，开车前往工作需要许多的汽油并因此会污染空气。 Man muss einsehen, dass angesichts der starken Verkehrsdichte man auf dem Weg zur Arbeit mehr Zeit zu widmen hat, wenn alle Menschen jeden Tag gleichzeitig zur Arbeit fahren. Die Zeit, die der Stau kostet, ist mindestens dreifach wie die Zeit, die man für ein unerwünschtes Telefonat zu Hause braucht. Ganz zu schweigen davon ist, dass die Fahrt zur Arbeit sehr viel Benzin verbraucht und damit auch die Luft verschmutzt. 现代交通技术使得许多办公室的工作在家里完成成为可能。在这个意义上办公室和家没有太大的区别。 Mit der modernen Kommunikationstechnik ist es jetzt möglich, viele Büroarbeiten zu Hause zu erledigen. In diesem Sinne gibt es keinen großen Unterschied zwischen Büro und zu Hause. 公司以及职员都可以从居家办公中获益。因为更长的工作时间企业必须为他们的职员支付附加费，这对企业来讲无疑是一份附加的负担。 Sowohl die Unternehmen als auch die Angestellten können von der Heimarbeit profitieren. Wegen der längeren Arbeitszeit müssen die Unternehmen einen Zuschlag für ihre Mitarbeiter zahlen, der sicherlich eine zusätzliche finanzielle Belastung für die Unternehmen ist. 当人在家里工作时拥有灵活的工作时间。因为人可以根据自己的意愿组织他工作的时间。优点是，人可以做一些日常活动并更多地关照他的家庭。 Man hat flexible Arbeitszeit, wenn man zu Hause arbeitet. Denn man kann die Zeit für seine Arbeit nach eigenem Wunsch organisieren. Der Vorteil ist, dass man seine eigenen Tätigkeiten machen und sich mehr um seine Familie kümmern kann. 人在家里可以高效地工作。人可以在早上稍微赖床一会，之后在写字桌前注意力完全集中地工作。 Man kann zu Hause effizient arbeiten. Man kann morgens ein bisschen länger schlafen und dann ganz konzentriert am Schreibtisch arbeiten. 当人在家里工作时人可以拥有更多自由的时间。人不需要每早早早起床并匆忙地驾驶汽车或搭乘公交去办公室工作。 Man kann mehr Freizeit haben, wenn man zu Hause arbeitet. Man braucht nicht jeden Morgen früh aufzustehen und ganz eilig mit Pkw oder Bus ins Büro zu fahren. Kontra: 家中有许多消遣，因此人经常不能集中精力工作并因此浪费许多时间。 Es gibt viele Ablenkungen zu Hause, so dass man sich oft nicht auf die Arbeit konzentrieren kann und damit viel Zeit verloren geht. 当许多工作者在家中工作时，效率会降低。如今在许多领域团队合作是必要的。在做许多重要的决定之前建议或者草稿必须被彻底讨论。这仅在办公室里奏效。当人不在办公室里他的职位上时，那么这将十分重要，呼叫所有的员工来一起研讨。人必须长时间的等待，直到某些人从家里来到办公室。 Wenn viele Erwerbstätige zu Hause arbeiten, sinken die Effizienzen. Heutzutage ist die Teamarbeit in vielen Bereichen notwendig. Vor vielen wichtigen Entscheidungen müssen Vorschläge oder Entwürfe ausdiskutiert werden. Das erfolgt nur im Büro. Wenn man nicht im Büro an seinem Arbeitsplatz ist, dann ist es sehr wichtig, alle Mitarbeiter zur Besprechung zusammenzurufen. Man muss lange warten, bis jemand von zu Hause ins Büro kommt. 当人在家里工作时，不可能每时每刻与同时交流。企业将由此受影响。因为合作以及团队精神对企业的成功来讲是第一线。当人已经习惯居家工作时，人不会喜欢同其他人一起工作。更糟糕的是，人会慢慢的从外部世界独立并可能因此罹患抑郁。 Es ist nicht mehr möglich, jederzeit mit Kollegen zu kommunizieren, wenn man zu Hause arbeitet. Davon wird vor allem das Unternehmen betroffen. Denn für Erfolg eines Unternehmens zählen in erster Linie die Zusammenarbeit und der Teamgeist. Wenn man schon an die Heimarbeit gewöhnt ist, arbeitet man nicht mehr gerne mit anderen Menschen zusammen. Noch schlimmer ist, dass man langsam von der Außenwelt isoliert ist und damit sehr wahrscheinlich an Depression leiden kann. 当更多公共服务的职员在家工作时，人会有更多的问题和困难。让人生气的是，当一些公共职位一直处于未被占据的状态。因此许多人的时间将被挥霍，因为公共服务技术人员的缺失而必须经常等待一整个上午。 Man hat mehr Probleme und Schwierigkeiten, wenn mehr Angestellte im öffentlichen Dienst zu Hause arbeiten. Es ist doch ärgerlich, wenn einige öffentlichen Stellen immer unbesetzt sind. So wird die Zeit vieler Menschen verschwendet, die wegen des Mangels an Sacharberitern im öffentlichen Dienst oft ganzen Vormittag warten müssen. ","date":"2020-07-15","objectID":"/testdaf-reference/:4:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"五、联网电视机在德国(现代媒体-人机互动、人际关系是否重要) Pro: 长远来看这样的设备对儿童和青少年有着积极的影响。使用现代仪器人可以与其他人不受时间限制地交换意见。借此人节省许多时间和精力。最首要的是当儿童和青少年在电视放送节目中找到有趣的话题时，他们可以直接同朋友们讨论它。他们再也无需打开一台电脑。 Solche Geräte haben auf lange Sicht positive Auswirkung auf Kinder und Jugendliche. Bei der Benutzung des modernen Gerätes kann man Meinungen ohne Zeitverzögerung mit anderen austauschen. Daher spart man viel Zeit und Energie. Vor allem wenn Kinder und Jugendliche interessantes Thema in der Fernsehen-Sendung finden, können sich direkt mit Freunden darüber diskutieren. Sie brauchen nicht mehr zusätzlich einen Computer einzuschalten. 这项技术发明对工作市场上境况的改善有所贡献。因为人们在看电视的同时也可以访问互联网，网上购物便成为了可能。借此许多工作岗位会被创造。 Zudem hat diese technische Erfindung zur Verbesserung der Situation auf dem Arbeitsmarkt beigetragen. Da Menschen beim Fernsehen gleichzeitig einen Internetzugang haben, ist das Online-Geschäft möglich. Dabei werden viele Arbeitsplätze geschafft. 除此之外这个新的设备提供给了青少年这样的可能性：建立他们对民主政治(Demokratie)的意识。过去的数年他们在电脑上花费了如此多的时间，他们几乎对电视新闻没有兴趣。凭借(Anhand)这项设备青少年可以在电视中跟踪(verfolgen)政治事件(Ereignisse)，并在此表达他们的观点，并积极参与电视中的一些民意调查。 Außerdem bietet dieses neue Gerät den Jugendlichen die Möglichkeit, ihr Bewusstsein von Demokratie zu bilden. In den letzten Jahren wenden sie so viel Zeit für Computer auf, dass sie sich kaum für die Fernsehennachricht interessiert haben. Anhand des Hybrid-TV-Gerätes können die Jugendlichen politische Ereignisse im Fernsehen verfolgen und dabei ihre Meinungen äußern und an einigen Umfragen im Fernsehen aktiv teilnehmen. Kontra: 对青少年来讲告别这类设备间或会越来越困难。 Es manchmal wird für Jugendliche immer schwieriger, sich von den Hybrid-TV-Geräten zu verabschieden. 尽管这类电视设备或多或少使得聊天变得轻松，但这并不意味着，没有互联网人便不能同他人交流。由此看来(Von daher)这项技术并不是不可或缺的。 Obwohl diese TV-Gerät mehr oder weniger das Chatten erleichert, aber das bedeutet nicht, dass man sich mit anderen ohne Internet nicht unterhalten kann. Von daher ist diese Technik nicht unentbehrlich. 这类设备会损伤青少年的健康。过度使用电视和互联网会损伤眼睛。 Solches Gerät schädet der Gesundheit der Jugendlichen. Die exzessive Fernseh- und Internetnutzung gefährdet die Augen. 同他人的交际中交往能力会衰退(nachlassen)。在交流过程中手势和面部表情扮演着重要的角色。人在看电视和线上聊天不需要这些重要的元素。这些缺失的联系有如下后果，人在真实的(richtigen)交流中对其他人的手势、表情不能立刻作出反应。 Die Kommunikationsfähigkeit lässt im Umgang mit anderen Menschen in der realen Welt nach. Bei der Kommunikation spielen Geste und Mimik auch eine wichtige Rolle. Diese wichtigen Elemente braucht man beim Fernsehen und Chatten nicht. Diese fehlende Übung hat die Folge, dass man beim richtigen Gespräch nicht mehr sofort auf Geste und Mimik der anderen Menschen reagieren kann. 互联网电视的消费造成了对电视、互联网的依赖，进而造成了青少年学校成绩的变差。长此以往的后果是，他们的职业前景被儿戏所替代。 Der Konsum vom internetfähigen TV-Gerät verursacht die Abhängigkeit vom Fernsehen und Internet und damit auch die Verschlechterung der Schulleistungen von den Jugendlichen. Die langfristige Folge davon ist, dass ihre berufliche Aussicht dadurch aufs Spiel gesetzt wird. ","date":"2020-07-15","objectID":"/testdaf-reference/:5:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"六、学业，职业和家庭(家庭与事业话题，尤其针对妇女) 此处两个观点为女性应选择文科(更好地照顾家庭)还是理科(更好的社会地位) Für Naturwissenschaft: 对女性自然科学家来说在毕业之后找到一份高薪水的工作并不困难。对许多家庭来说一个稳定的资金来源是儿童抚养的最重要的因素。 Es fällt den Naturwissenschaftlerinnen nicht schwer, eine gut bezahlte Arbeit nach ihrem Studienabschluss zu finden. Für viele Familien ist eine sichere finanzielle Quelle der Schlüsselfaktor für die Kindererwartung. 在现代社会中男性已参与进家庭工作。他们也以他们事业有成的妻子而自豪。 Männer in moderner Gesellschat sind bereit, die Hausarbeit mitzumachen. Sie sind auch stolz auf ihre beruflich erfolgreiche Frau. 加班感觉不一定是令人厌烦的，只要这份工作给女性带来愉悦。 Die Überstunden sind nicht unbedingt als lästig empfunden, sobald die Arbeit den Frauen Spaß macht. ( Die Argumentation, dass dioe Frauen mit einem Studienabsclhluss in Geisteswissenschaften eine leichte Arbeit bekommen und sich mehr um Familie und Kinder kümmern können, ist nicht überzeugend.) Für Geisteswissenschaft 女性在自然科学、工学学业结束后可能可以得到一份高薪职业并以此改善资金条件。但这样的工作往往与许多缺陷捆绑在一起。她们中的不少人必须加班并且工作对女性来讲太过劳累(stressig)。 Vielleicht können die Frauen nach dem Studium in Natur- und Ingeniurwissenschaft eine gut bezahlte Arbeit bekommen und damit die finanzielle Lage verbessern. Aber soclche Arbeit ist oft mit vielen Nachteilen verbunden. Nicht selten müssen sie Überstunden machen und die Arbeit ist für die Frauen sehr stressig. 女性人文科学家工作在愉悦的氛围中并且工作带来他们愉悦。女性可以在出版社(Verlag)或编辑室(Redaktion)安静地工作，并不需要在机器旁边转悠或不停地出差。 Die Geisteswissenschafterinnen arbeiten in der angenehmen Atmosphäre und die Arbeit macht ihnen Spaß. Im Verlag oder in der Redaktion können die Frauen in Ruhe arbeiten und brauchen nicht, an die Maschinen zu gehen oder ständig Diensreise zu machen. 女性在出版社或编辑部可以经常与不同的作家就有趣地主题交流。所有这些工作都给女性带来了欢乐。当女性有育儿计划时，这尤为重要。 Frauen können im Verlag oder Redaktion oft mit verschiedenen Autoren kommunizieren, über interessante Themen sprechen. All diese Arbeiten bringen den Frauen Freude. Dies ist besonders wichtig, wenn die Frauen einen Kinderplan haben. 许多女性想要自由时间，因为他们可以在他们的自由时间里教育孩子，同孩子玩耍、和孩子一同做(unternehmen)其他的事情。对大多数女性来讲与孩子在一起时的愉悦不能与金钱或事业相提并论。 Viele Frauen wollen Freizeit haben, denn sie können in ihrer Freizeit Kinder erziehen, mit Kindern spielen und etwas mit ihren Kindern gemeinsam unternehmen. Für die meisten Frauen kann die Freude mit Kindern nicht mit Geld oder beruflicher Karriere gleichgesetzt werden. ","date":"2020-07-15","objectID":"/testdaf-reference/:6:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"七、漂亮的包装？(环保话题，对环境和生态的影响) Pro: 带有包装的生活用品很容易被带走和存储。这些优点对这些人尤为重要：忙于工作并因此一次性购买大量的生活用品。对企业来讲包装也是成功的钥匙。因为企业使用创新的、漂亮的包装，顾客的购买决定可以被建议并且企业可以由此获得高额的利润。 Das Lebensmittel mit Verpackung ist leicht zu tragen und lagern.Diesen Vorteil sehen besonders die Menschen, die mit der Arbeit beschäftigt sind und deswegen Lebensmittel oft einmal in großer Menge kaufen. Auch für die Unternehmen sind die Verpackung der Schlüssel zum Erfolg. Weil Unternehmen kreative und schöne Verpackung benutzen, kann die Kaufentscheidung der Kunden suggeriert werden und die Unternehmen können dadurch hohen Gewinn erzielen. 漂亮的包装可以(in der Lage sein)，提高物品的吸引力（Anziehungskraft）并借此促成消费。 Die schöne Verpackung ist in der Lage, die Anziehungskraft der Ware zu erhöhen und daher den Konsum zu fördern. Kontra: 过度的（übertrieben）包装生产对环境十分有害(umweltschädlich)， 因为大多数包装是纸质的。也就是说，为了得到（gewinnen）生产包装的原材料（Rohstoff），大量的(zahlreiche)树木将被砍伐，这完全不利于可持续发展（nachhaltige Entwicklung） Die übertriebene Herstellung der Verpackung ist sehr umweltschädlich, weil die Verpackung meistens aus Papier ist. Das heißt, dass zahlreiche Bäume gefällt werden, um den Rohstoff für die Herstellung von Verpackungen zu gewinnen, was gar nicht günstig für die nachhaltige Entwicklung ist. 包装的生产造成了（erzeugen）许多难以被清理的（K.I. rntsorgen）垃圾，这将种下（säen）地表和水严重的（fatal）祸根（Saat(本意幼苗)） Die Produktion der Verpackung erzeugt viele schwer zu entsorgende Abfälle, die die Saat der fatalen Verschmutzung im Boden und Wasser sät. 生产商更多的注意在产品的外观而不是质量上。因为按照他们的观点单凭漂亮的包装就可以提升销量（Umsatz）,生产商减少了许多生产成本（Erzeugungskosten） Die Hersteller achten mehr auf das Ansehen von Verpackungen statt die Qualität der Produkten. Da die schöne Verpackung ihrer Meinung nach allein den Umsatz erhöhen kann, verringert der Hersteller viele Erzeugungskosten. 人必须明白（einsehen），多面的包装影响顾客的购买决定。消费者（Verbraucher）可能因为华丽的（prächtig）包装而购买一个质量低下的产品。 Man muss doch einsehen, dass die vielfältige Verpackung die Kaufentscheindung der Konsumenten beeinflusst. Die Verbraucher können wegen der prächtigen Verpackung ein Produkt mit niedriger Qualität kaufen. 一些包装难以被循环利用（recycle），当他们由塑料生产比如塑料薄膜（Plastikfolie）和塑料袋（Plastiktüte）。当人随意丢弃（herumwerfen）它们时，他们漂浮（schweben）在空中或者躺在地上。这样环境将被污染。一个塑料袋经常被短时间的使用，它们降解（Zum Verrotten）却需要至多500年。人类的健康也会被危及生命的细菌威胁，当生活用品的包装不整洁地（ungereinigt）乱放（herumliegen） Manche Verpackung sind schwer zu recyceln, wenn sie aus Plastik bestehen wie Plastikfolie und Plastiktüte. Wenn man sie herumwirft, schweben sie dann in der Luft oder liegen auf dem Boden. Dadurch wird die Umwelt verschmutzt. Eine Plastiktüte wird oft nur für kurze Zeit verwendet, zum Verroten braucht sie jedoch bis zu 500 Jahre. Auch menschliche Gesundheit wird durch lebensgefährliche Bakterien gefährdet, wenn die Lebensmittelverpackungen ungereinigt herumliegen. 这些包装须要消耗（verbrauchen）运输过程中附加的能量。 当来自全世界越来越多的货物通过飞机或者船运输的时候，巨量的(enorm)燃料(Brennstoffe)将被消耗。 Diese Verpackungen verbrauchen zusätzliche Energie beim Transport. Wenn immer mehr Waren aus der ganzen Welt mit Flugzuegen oder Schiffen transportiert werden, werden enorme Brennstoffe verbraucht. 他也与经济问题有关（Es handelt sich um…）。消费者将被迫（zwingen）支付更多仅仅因为漂亮的包装而产生的附加的花费。 Es handelt sich auch um die finanzielle Frage. Die Verbraucher werden gezwungen, mehr für die zusätzliche Kosten zu bezahlen, die allein wegen schöner Verpackung entstehen. ","date":"2020-07-15","objectID":"/testdaf-reference/:7:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"八、媒体(传统媒体与现代媒体之间的矛盾与互补) Pro( Die traditionellen Medien werden durch die modernen Medien ersetzt): 人不可以随时随地阅读很多书籍。当人出于旅行或者Vorlesung的需要带着许多书时，是很笨重的（Es fällt vielen schwer） Man kann nicht jederzeit und überall viele Bücher lesen. Es fällt vielen schwer, viele Bücher mitzunehmen, wenn man sie auf der Reise oder zur Vorlesung braucht. 这有关资源浪费。为了生产纸张，人需要许多的木材（Holz）。这样的后果是，许多森林（Wälder）被摧毁了。当太多的样品被印制的时候，这意味着木材、水、能量资源的极大浪费。森林的砍伐也可以将肥沃的（fruchtbar）地区变为（in A. verwandeln）荒漠（Wüste） Es geht um Ressourcenverschwendung. Um Papier herzustellen, braucht man sehr viel Holz. Die Folge davon ist, dass viele Wälder zerstört sind. Wenn zu viele Exemplare gedruckt werden, die dann später wegen geringen Verkaufs vernichtet werden müssen, bedeutet dies eine enorme Verschwendung von Ressourcen von Holz, Wasser und Energie. Auch die Abholzung der Wälder kann die fruchtbare Landschaft in eine Wüste verwandeln. 青年人使用新的媒体如电脑可以快速发现多面的、及时的消息，而不是经常阅读书本里早已过时的（veraltete）知识。 Die jungen Menschen sind mit den neuen Medien wie Computer in der Lage, vielfältige und aktuelle Informationen schnell zu erfahren, statt dass oft schon veraltete Wissen in den Büchern zu lesen. 在电脑和因特网上的知识比在书本上的知识更加生动直观(veranschaulich)，这将促进青少年学习。 Das Wissen im Computer und Internet ist veranschaulicher als in den Büchern, was die Jugendlichen zum Lernen motiviert. Übergang: 许多人认为，传统媒体如书籍和报纸是需求资源的（ressourcenintensiv）、这是清楚的，成产纸张的需要木材。但是使用现代科技人可以毫无问题的回收旧的纸张并再用于书籍和报纸的生产（bereitstellen）。相反的电子器件是有毒的（giftig）并因此在销毁（Vernichtung）时须要一个特定的过程。 Viele behaupten, dass die traditionellen Medien wie Bücher und Zeitungen ressourcenintensiv sind. Es ist klar, dass bei der Herstellung von Papier Holz gebraucht wird. Aber mit modernen Technik kann man jetzt das Altpapier problemlos recyceln und wieder zum Druck von Büchern und Zeitungen bereitstellen. Im Gegensatz dazu ist der Elektro-Schrott zum Teil giftig und benötigt deshalb einen besonderen Prozess bei der Vernichtung. 当年轻人整日从事电脑工作，尽管这可能对他们眼睛有害，但这可以通过父母的管控而避免发生。 Zwar konnte es schädlich für ihre Augen, wenn sich die jungen Leute den ganzen Tag mit dem Computer beschäftigen, was durch Kontrolle der Eltern aber vermeiden werden kann. Kontra( Die traditionellen Medien werden durch die modernen Medien nicht ersetzt): 书籍的优点显而易见：人可以抓握它，翻页（in ihnen blättern），闻嗅并放在书架上（ins Regal stellen）作为教育显著的象征。 Der Vorteil von Bücher liegt auf der Hand, dass man sie anfassen können, in ihnen blättern, sie riechen und als sichtbare Zeichen von Bildung ins Regal stellen. 书籍还有一个优点：人在阅读书籍过程中，尤其是他们的朋友或亲戚已经读过的书，体验特定的（）感觉和情绪，因为人在此过程中自动想起这些人。书籍的这个功能是电子阅读器没有的。 Bücher haben einen weiteren Vorteil, dass man beim Lesen von Büchern, vor allem von den Büchern, die seine Freunde oder Verwandte schon mal gelesen haben, gewisse Gefühle und Emotionen spürt, weil man sich dabei automatisch an diese Personen erinnert. Diese Funktion von Büchern hat ein elektronisches Lesegerät nicht. 人可以随处阅读书籍和报纸。人可以在野营地（Camping-Platz）或在公园毫无问题的翻阅书籍、阅读日报上的消息。而电脑必须有（Strom vorhandeln sein）电流。 Man kann Bücher und Zeitungen überall lesen. Auf dem Camping-Platz oder im Park kann man problemlos in den Bücher blättern und Nachrichten in der Tageszeitung lesen. Für den Computer muss Strom vorhanden sein. 这事关眼睛的健康。当人数小时忙于电脑时，首先（zunächst）人感觉到眼部不适（Unbequemlichkeit）。儿童和青少年恰好处于发育时期（Wachstumsphase），此时他们的眼睛还是可塑的。当他们每天阅读屏幕上的文章和消息时，他们的眼睛会被强烈地损害（gefährden）。 Es geht um die Gesundheit der Augen. Wenn man stundenlang mit dem Computer beschäftigt ist, spürt man zunächst die Unbequemlichkeit der Augen. Kinder und Jugendliche befinden sich gerade in der Wachstumsphase, wobei ihre Augen noch formbar sind. Wenn sie täglich Artikel und Informationen auf dem Bildschirm lesen, werden ihre Augen stark gefährdet. 这与内容有关。在互联网上有许多不适合儿童和青少年的东西。因为儿童和青少年还缺乏自我约束（Selbstdisziplin）和判断力（Urteilvermögen），他们在网上冲浪的时候很容易会被欺骗（verführen） Es handlet sich um die Inhalte. Im Internet gibt es viele Sachen, die den Kindern und Jugendlichen nicht geeignet sind. Da die Kindern und Jugendlichen noch an Selbstdisziplin und Urteilvermögen fehlt, können sie beim Surfen im Inter","date":"2020-07-15","objectID":"/testdaf-reference/:8:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"九、Pkw和环境(交通工具与环保，可延伸到绿色出行、自行车出行) Meinungen: 首先人应该改变他的生活习惯（Gewohnheit）。当然这不是如此舒服的：当人带着满满的购物袋（Einkaufstüte）乘坐公交或城市轻轨回家时。但是许多优点不应该被忽略。乘坐公共交通工具人为节省能源做出了贡献。一辆公交车满载时（volle Belastung）人均（pro Kopf）将比Pkw消耗更少的汽油。除此之外人可以借此节省时间。许多机车也意味着所有街道上的堵塞。人乘坐诸如地铁的公共交通工具比开自己的Pkw更快的到达目的地（ans Ziel kommen）。不适也可以被避免，人通过在住所附近的小商店购买重要的生活用品或在网上购买（stellen）想要的物品。没有自己的Pkw而使用汽车去上班也可以通过共享汽车（Car-Sharing）来实现。一些同事可以一同驾驶汽车。借此人不仅节省了汽油的花销，也可以在行驶过程（Fahrt）中聊天。借此友谊会被深化（vertiefen）。这有利于（Dies dient dayu, dass…），人在日常生活和岗位上一直拥有欢乐。 Erstens sollte man seine Gewohnheiten ändern. Natürlich ist es nicht so bequem, wenn man mit vollen Einkaufstüten mit dem Bus oder der Straßenbahn nach Hause fährt. Aber viele Vorteile sollten nicht vernachlässtigt werden. Mit den öffentlichen Verkehrsmitteln trägt man zum Sparen von Energie bei. Bei voller Belastung verbraucht ein Bus viel weniger Benzin pro Kopf als ein Pkw. Außerdem spart man dabei die Zeit. Viele Autos bedeuten auch Stau auf allen Straßen. Oft kommt man mit öffentlichen Verkehrsmitteln wie U-Bahn viel schnell ans Ziel als mit dem eigenen Pkw. Auch die so genannte Unbequemlichkeit lässt sich vermeiden, indem man in kleinen Laden in der Nähe der Wohnung wichtige Lebensmittel kauft oder die gewünschten Sachen im Internet bestellt. Auch die Nutzung eines Autos zur Arbeit kann ohne eigenen Pkw realisiert werden durch Carsharing. Einige Kollegen können zusammen ein Auto fahren. Dabei spart man nicht nur Geld für Benzin, sondern man kann sich während der Fahrt unterhalten. Dadurch wird die Freundschaft vertieft. Dies dient dazu, dass man immer Freude im Alltag und am Arbeitsplatz hat. 其次这有关汽车制造业（Automobil-Industrie）里的技术发展。当人要买节省能源的汽车时，汽车工厂将会被促使（zwingen）发展环境友好的发动机。一个典型的例子是氢能源驱动（Hybride-Antrib）。尽管现在这样的汽车是昂贵的，但它属于（zu D. gehören）未来。尤其是当人长距离（Strecke）行驶时，如去度假（auf den Urlaub），人可以节省许多的金钱并向空气排放（in die Luf ausstoßen）更少的CO2。在汽车工厂或想要掌控（behaupten）未来的人，必须现在投资(in A. investieren)这些技术。并且消费者也应该支持（unterstützen）这项发展。当所有这些点子转化为实际（in der Praxis umsetzen）时，环境将一步步地被减轻负担（entlasten）。 Zweitens geht es um technische Entwicklung in der Automobil-Industrie. Wenn man energisparendes Auto kaufen will, wird die Autoindustrie gezwungen, umweltfreundliche Motoren zu entwickeln. Ein typisches Beispiel ist der Hybride-Antrieb. Derzeit ist solches Auto zwar teuer, gehört aber zur Zukunft. Besonders wenn man lange Strecke fährt, wie auf den Urlaub, kann man viel Geld sparen und viel weniger CO2 in die Luft ausstoßen. Wer sich in der Automobil-Industrie auch in Zukunft behaupten will, muss jetzt schon in diese Technologie investieren. Und Verbraucher sollten auch diese Entwicklung unterstützen. Wenn all diese Ideen in der Praxis umgesetzt werden, wird die Umwelt Schritt für Schritt entlastet. ","date":"2020-07-15","objectID":"/testdaf-reference/:9:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"十、事业选择与专业选择(相互关系) Meinungen: 我的个人观点是，成功的学业更确切地说（eher）来自动机。尽管几乎所有的高中毕业生（Abiturienten）有一个目标：凭借着他们的毕业证书找到一份高薪水的职业，借此可以使得事业飞黄腾达（Karrierer）、物质富裕（materieller Wohlstand）成真。但人必须了解（damit rechnen），钱并不一直是作为幸福（Glück）和生活欢乐的唯一决定性的前提条件。更重要的是精神上的丰富（geistige Bereicherung）和自我实现（Selbstverwirklichung）。如果高中毕业生对一个专业如Maschinenbau或Informatik完全没有兴趣（Interessie für）的时候在他们的学习过程中他们也找不到快乐。与之相反如果年轻人喜欢这门学科，他们是一直有动力的。当他们自己在学习过程中有大的困难时，他们可以经受得住（aushalten）并以一个好的成绩结束学业。 Prinzipiell bin ich der Auffassung, ein erfolgreiches Studium eher vom Motiv bestimmt ist. Zwar haben fast alle Abiturienten ein Ziel, dass sie mit ihrem Studienabschluss eine gut bezahlte Arbeit finden, wodurch sie Karriere und materiellen Wohlstand verwirklichen können. Dabei versuchen sie, ein glückliches Leben zu führen. Aber man muss damit rechnen, dass das Geld nicht immer die einzige entscheidende Voraussetzung für das Glück und die Freude des Lebens schafft. Noch wichtiger sind die geistige Bereicherung und Selbstverwirklichung. Wenn die Arbiturienten überhaupt kein Interesse für ein Studiunfach wie Maschinenbau oder Informatik haben, finden sie auch keinen Spaß während ihres Studiums. Im Vergleich dazu sind die jungen Menschen ständig motiviert, wenn das Studienfach ihnen gefällt. Selbst wenn sie während des Studiums große Schwierigkeiten haben, können sie es aushalten und ihr Studium mit guten Leistungen absolvieren. 广为人知的意见是，如学习如哲学或教育学的人文科学家，很难找到一个工作岗位，是彻底（durchaus）不正确的。所有人都知道，哲学视作许多学业的基础（Grundlage）。在我们现代社会中没有哲学知识的工程师几乎不能想象。教育学也是科技发展的根基（Fundament）并培养了（für A. sorgen）有资质的工作人员。因此长远来看人文科学家也有欣欣向荣的（blühend）未来。 Die weit verbereitete Auffassung ist, dass die Geistenswissenschaftler, die z.B. Phiilosophie oder Pädagogie studieren, nur sehr schwer einen Arbeitsplatz finden, durchaus nicht korrekt. Es ist allen bekannt, dass Philosophie als Grundlage für viele Studienfächer gilt. Ingenieure ohne philosophische Kenntnisse sind in unserer modernen Gesellschaft kaum zu denken. Auch Pädagogik ist das Fundament für die technische Entwicklung und sorgt für qualifizierte Mitarbeiter. Deswegen haben die Geistenswissenschaftler auch auf lange Sicht blühende Zukunft. ","date":"2020-07-15","objectID":"/testdaf-reference/:10:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"十一、志愿生态年——是或否？(是都应该从事公益活动，人与社会责任) Pro: 人必须认识到，企业偏爱（bevorzogen）有社会经验的学生。因此这样的人：没有实习经验毕业的人，在寻找职位的过程中碰到更多的困难（auf Schwierigkeiten stoßen） Mann mus damit rechnen, dass das Unternehmen einen Studierenden mit sozialen Erfahungen bevorzugt. Deswegen haben diejenigen, die früher einen Hochschulabschluss ohne praktische Erfahrungen haben, bei der Suche nach einer Stelle auf mehr Schwierigkeiten stoßen. 经验对个人成长时必要的。在为环保、动物保护工作时他们不仅可以获得专业知识，他们的责任意识（Verantwortungsbewusstsen）也会被提高。在儿童-青少年工作或照看病人时他们也学到，人应该如何应对在关键（kritisch）情况里的突发事件（plötzliches Geschehen）。也就是说，他们的处理能力（Handlungsfähigkeit）也会被完善。 Die Erfahungen sind notwendig für die persönliche Entwicklung. Beim Einsatz für umweltschutz oder Tierschutz können sie nicht nur Fachkenntnisse erwerben, auch ihr Verantwortungsbewusstsen wird erhöht. Bei Kinder- und Jugendlichenarbeit oder Krankenpflege lernen sie auch, wie man in kristischer Situation auf das plötzliche Geschehen reagieren soll. Das heißt, dass ihre Handlungsfähigkeit auch verbessert wird. 人应该在社会视角下判断这一个志愿年。首先社会支出会通过一个志愿年而减少。人可以使用这些省下来的钱帮助许多处于贫困处境的（aus armen Sozialverhältnissen）人。 Man sollte ein freiwilliges Jahr unter dem gesellschaftlichen Aspekt beurteilen. Zuerst wird die soziale Ausgabe durch ein freiwilliges Jahr reduziert. Mit dem ersparten Geld kann man vielen Menschen aus armen Sozialverhältnissen helfen. 专业工作者也可以从志愿年获益。因为志愿者已经接手日常工作（Routinearbeit），这些专业工作者可以专注于核心（Wesentlische）。 Facharbeiter können auch vom freiwilligen Jahr profitieren. Da die Freiwilligen Routinearbeit übernommen haben, können sich die Facharbeiter auf das Wesentliche konzentrieren. 人应该站在个人发展角度观察（betrachten）这个现象（Erscheinung）。当年轻人在医院照顾病人时，他们必须了解患者的需求。借此他们不仅可以在医生或护士旁学习专业知识，他们也学习他们如何与他人交流。 Man sollte diese Erscheinung unter dem Aspekt von persönlicher Entwicklung betrachten. Wenn die junge Leute sich im Krankenhaus um die Patienten kümmern, müssen sie die Bedürfnisse der Patienten kennen. Dadurch können sie nicht nur die Fachkenntnisse beim Arzt oder Krankenschwester lernen, sondern auch sie lernen, wie sie mit anderen zu kommunizieren. 除此之外人应该站在社会视角下评价一个志愿年。志愿者促进了社会和谐（die Harmonisierung der Gesellschaft）。他们在日常生活中无偿（ohne Belohnung）帮助残疾人。他们为残疾人或老人购物并同这些人聊天，借此这些人不再感觉孤独（einsam）、无助。他们感受到社会的温暖和生活中的愉悦。所有的这些都对整体（gesamt）社会起积极作用。 Außerdem sollte man ein freiwilliges Jahr unter dem sozialen Aspekt beurteilen. Die Freiwilligen tragen auch zur Harmonisierung der Gesellschaft bei. Sie helfen den Behinderten im Alltagsleben ohne Belohnung. Sie kaufen für die Behinderten oder alte Menschen ein und unterhalten sich mit diesen Menschen, damit sich diese Menschen nicht mehr einsam und hilflos fühlen. Sie spüren die Wärme der Gesellschaft und Freude im Leben. All das wirkt sich positiv auf die gesamte Gesellschaft aus. 一个志愿年有这样的功能，青少年可以借此学习，当他们帮助一个人的时候承担责任（Verantwortung übernehmen） Ein freiwilliges Jahr hat die Funktion, dass Jugendliche dabei lernen können, Verantwortung zu übernehmen, wenn sie einem helfen. Kontra: 青少年失去了有价值的、本来可以用来为获取专业知识安排（）的时间。当他们真的想为环境、动物界、人类做一些什么（in Not tun）的时候，他们必须有相对应的专业知识。仅仅有一颗热情的心是不够的（nicht ausreichen） Jungendliche verlieren wertvolle Zeit, die sie eigentliche für das Erwerben von Fachkenntnissen einsetzen können. Wenn sie wirklich etwas für die Umwelt, die Tierwelt, die Menschen in Not tun wollen, müssen sie entsprechende Fachkenntnisse haben. Nur ein warmes Herz reicht nicht aus. 除此之外越来越多固定的工作职位会因此受威胁，因为志愿者再工作过程中不挣钱。处于花费理由许多机构（Einrichtung）或企业要为容易学习的工作（leicht erlernte Arbeit）安排廉价劳动力。这样的后果是，越来越少的工作岗位将被提供。 Außerdem werden immer mehr feste Arbeitsplätze dadurch bedroht, denn die Freiwilligen verdienen kein Geld bei der Arbeit. Aus Kostengründen wollen viele Einrichtung oder Untenehmen billige Arbeitskräfter für leicht erlernte Arbeit anstellen. Die Folge davon ist, dass immer weniger Arbeitsplätze angeboten werden. 许多岗位如患者护理和残疾人帮助是挑剔的（anspruchsvoll）并这样的工作岗位要求特殊的专业知识。没有医药知识的青少年的工作，会导致病人照顾复杂（Komplikation） Schließlich sind viele Stellen wie Krankenpflege und Behinderthilfe anspruchsvoll und solche Arbeitsplätze spezielle Fachkenntnisse verlangen. Die Anstel","date":"2020-07-15","objectID":"/testdaf-reference/:11:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"十二、全天学校(青少年教育问题，是否应该给青少年更多自由发展空间) Pro: 父母可以从全天学校获益良多。因为他们再也不用一直去照顾他们的孩子，即使在下午他们所在的工作岗位上仍有许多需要做的事情。除此之外他们也将从他们孩子的监护工作中获得解放(befreit sein)。 Die Eltern können von der Gantztagesschule vieles profitieren. Denn sie brauchen nicht mehr, sich ständig um ihre Kinder zu kümmern, auch wenn sie nachmittags am Arbeitsplatz noch viel zu erledigen haben. Außerdem sind sie von der Btreuungsarbeit ihrer Kinder befreit. Kontra: 然而学校有传授知识的任务。但它们不应该不停地（pausenlos）灌输（eintrichtern）知识。因为学生也需要时间，消化所学的并正确地理解。 Die Schule hat zwar die Aufgabe, das Wissen zu vermitteln. Aber sie sollten das Wissen nicht pausenlos eintrichtern. Denn die Schüler brauchen auch Zeit, das Gelernte zu verdauern und richtig zu verstehen. 除此之外学生需要放松的时间。科学已证明的是（Es ist wissenschaftlich bewiesen, dass），人在学习过程中集中注意力在学习材料上最长1小时。因此下午的课间休息（der unterrichtsfreie Nachmittag）对高效学习时不可或缺的。 Außerdem benötigen die Schüler die Zeit, sich zu entspannen. Es ist wissenschaftlich bewiesen, dass man sich beim Lernen höchsten eine Stunde auf den Lernstoff konzentrieren kann. Deswegen ist der unterrichtsfreie Nachmittag für das effektive Lernen unentbehrlich. 全天雪线应该在健康的角度下思考。学生需要有规律的体育活动。当他们下午没有课程时，他们可以和朋友们踢足球、游泳或打羽毛球（Federball）。这不仅关于身体训练，也关于他们交流能力的提高。在一同玩耍的过程中他们可以亲自体会，合作、信任、团结（Zusammenhalt）是多么的重要。所有的这些能力对个人成长是有着大的含义的。 Zudem sollte die Ganztagsschule unter dem gesundheitlichen Aspekt betrachten. Die Schüler brauchen regelmäßige sportliche Aktivität. Wenn sie nachmittags keine Schule haben, können sie mit Freunden Fußball spielen, schwimmen gehen oder Federball spelen. Dabei geht es nicht nur um das körperliche Training, sondern auch um die Steigerung ihrer Kommunikationsfähigkeit. Beim Zusammenspiel können sie persönlich erleben, wie wichtig Kooperation, Vertrauen und Zusammenhalt sind. All diese Fähigkeiten sind für die persönliche Entwicklung von großer Bedeutung. 下午的课间休息提供了学生更好控制自己的可能性。他们可以学习，人如何为学习和娱乐（Vergnügung）分配（einteilen）时间，如何有意义地安排（arrangieren）空闲时间。这不仅对他们的在校时间是重要的，也对他们的整个生活很重要。 Schließlich bietet der unterrichtsfreie Nachmittag den Schülern die Möglichkeit, sich selbst zu kontrollieren. Sie können lernen, wie man Zeit für das Lernen und die Vergnügung einteilt und wie man seine Freizeit sinnvoll arrangiert. Das ist nicht nur wichtig für ihre Schulzeit, sondern auch für ihr ganzes Leben. ","date":"2020-07-15","objectID":"/testdaf-reference/:12:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"十三、互联网是机会吗？(现代媒体对经济发展的影响) Pro: 互联网提供了机会，所有人自由地表达（Meinungen äußern）自己的意见。每天再互联网上有关于政治、日常生活中的变化如生活用品价格的上涨的个人意见不同的调查（Umfrage）。通过互联网人们可以知道他们所处的困境（in Notlage ihre Schwierigkeiten）。 Das Internet bietet die Möglichkeit, dass alle Menschen ihre Meinung frei zu äußern. Jeden Tag gibt es im Internet verschiedene Umfragen um die eigene Meinung über Politik, Veränderugen im Alltag wie Preiserhöhung von Lebensmitteln. Durch das Internet können die Menschen in Notlage ihre Schwierigkeiten wissen lassen. 除此之外人应该从经济的角度评论增长的互联网使用。尽管不排除，互联网上有欺诈（Betrügerei）。 Außerdem sollte man die zunehmende Nutzung vom Internet aus der wirtschaftlichen Perspektive beurteilen. Zwar ist es nicht auszuschlißen, dass es im Internet Betrügerei gibt. 人也应该明白，互联网为一个国家的经济增长做出了巨大贡献。许多小公司是通过在线商务（Online-Geschäft）被拯救的。现在它们大多数（überwiegend）通过互联网销售它们的产品或服务。借此许多失业者再次找到了工作岗位。 Doch man muss einsehen, dass das Internet großen Beitrag zur wirtschaftlichen Entwicklung eines Landes leistet. Viele kleine Firmen sind durch das Online-Geschäft gerettet. Jetzt verkaufen sie ihre Produkte oder Dienstleistungen schon überwiegend durch das Internet. Dabei haben viele Arbeitslose wieder neuen Arbeitsplatz gefunden. 此外人应该从国家与人民之间的文化交流观察互联网现象。尽管不能绝对地（hunderprozentig）否认：歧视意见（Diskriminierungsideen）或敌视（Feindseligkeit）自我传播。 Weiterhin sollte man das Phänomen vom Internet aus der Sicht des Kulturaustausches zwischen den Ländern und Völkern betrachten. Es ist zwar nicht hunderprozentig zu vermeiden, dass sich Diskriminierungsideen oder Feindseligkeit verbreiten. 互联网时人们可以是人们认知其他的风俗（Sitten）和文化。借此人发现，其他州的人如何生活，人在国际贸易（internationaler Handel）应该尊重（berücksichtigen）何种传统和习惯。 Doch das Internet ermöglicht den Menschen, andere Sitten und Kulturen kennenzulernen. Dabei erfährt man, wie man in anderen Kontinenten lebt und welche Traditionen und Gewohnheiten man beim internationalen Handel berücksichtigen soll. Kontra: 当管控被忽略(vernachlässigen)时，会产生私人数据在未经当事人(Betroffene)的允许便被公布在互联网上的危险。 Es besteht die Gefahr, dass private Daten ohne Erlaubnis der Betroffenen im Internet veröffentlicht werden, wenn die Kontrolle vernachlässigt wird. ","date":"2020-07-15","objectID":"/testdaf-reference/:13:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"十四、学业还是工作(青少年教育，是否应该打工) Pro: 学生有机会，将他们在学校已学到的专业知识在实习中转化，这对往后的学习和职业生涯十分重要。一方面他们可以深化已学过的知识并正确地掌握学习的意义。另一方面他们在工作过程中可以学到新的东西。借此他们将积极学习（zum Lernen motiviert werden）。 Die Schulkinder haben wohl die Möglichkeit, die Fachkenntnisse, die sie in der Schule gelernt haben, in die Praxis umzusetzen, was besonders wichtig für das spätere Studium und Berufsleben ist. Zum einen können sie das Gelernte vertiefen und den Sinn des Lernens richtig begreifen, zum anderen können sie sich etwas Neues während der Arbeit erwerben. Dadurch werden sie zum Lernen motiviert. 他们可以更好地理解父母的辛劳（Anstreng），当他们在家照料一个年幼的兄弟姐妹（Geschwister）的时候。借此他们可以发现，抚养一个孩子（ein Kind aufziehen）有多么的困难。 Sie können die Anstreng ihrer Eltern besser verstehen, wenn sie sich z.B. zu Hause um kleine Geschwister kümmern. Dadurch können sie erfahren, wie schwer es ist, ein Kind aufzuziehen. 他们可以提高他们的处理能力和思维能力。在工作过程中他们得到特定的任务：偶尔这些任务不是太容易被完成（erledigen）。在这种情况下（In diesem Fall）学生必须想出可能的解决方案并对不同的情境做反应。这是一个好的训练。因此有兼职的学生在学习过程中有更少的困难，相比没有兼职工作的学生。 Sie können ihre Handlungsfähigkeit und Denkfähigkeit erhöhen. Beim Jobben bekommen sie bestimmte Aufgaben, die manchmal nicht so ganz leicht zu erledigen sind. In diesem Fall müssen Schulkinder mögliche Lösungen ausdenken und auf verschiedenen Situationen reagieren. Das ist ein gutes Training. Deswegen haben die Schulkinder mit Nebenjob weniger Schwierigkeiten beim Lernen in der Schule als die Schulkinder, die keinen Nebenjob machen. 因为工作市场上的激烈竞争实习经验在求职过程中扮演者越来越重要的角色。学校之后的一份工作有助于提供学生一个个人发现工作岗位上视角（？）的机会。他们可以在工作过程中观察，现实生活中所有的一切是被如何完成的以及哪些知识是必要的。 Wegen der harten Konkurrenz auf dem Arbeitsmarkt spielen praktische Erfahrungen eine immer wichtigere Rolle bei der Suche nach einer Arbeit. Ein Job nach der Schule trägt dazu bei, den Schulkindern eine Chance anzubieten, das Gesehen am Arbeitsplatz persönlich zu erfahren. Sie können während des Jobs beobachten, wie alles in der Realität gemacht wird und welche Kenntnisse dabei erforderlich sind. 除此之外学生的自立能力和处理能力通过工作而被提高。有时学生必须应对不同的问题反应并在此过程中同专业工作者一同找到合适的解决方法。这种能力不在教科书里并只能通过工作被获得。有这种能力的人在未来得到更好地机会。 Außerdem werden die Selbstständigkeit und Handlungsfähigkeit der Schüler durch den Job erhöht. Manchmal müssen die Schulkinder auf verschiedene Probleme reagieren und dabei entsprechende Lösungen mit Facharbeitern zusammen finden. Diese Fähigkeit steht nicht in den Lehrbüchern und kann nur durch Job erworben werden. Wer solche Fähigkeit hat, bekommt in Zukunft bessere Chance. 学生会被工作激发学习知识的积极性。在实习过程中他们认识到知识的必要性之后，他们想要自己学习知识。他们在学习过程中不再感到无聊。 Schließlich werden die Schulkinder durch Job zum Lernen von Kenntnisse motiviert. Nachdem sie in der Praxis die Notwendigkeit der Kenntnisse erkannt haben, wollen sie selbst Kenntnisse lernen. Sie fühlen sich beim Lernen nicht mehr langweilig. Kontra: 一份兼职工作或多或少都会花费时间和精力。 Ein Nebenjob kostet mehr oder weniger Zeit und Energie. ","date":"2020-07-15","objectID":"/testdaf-reference/:14:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"十五、年长或年轻的教师？(青少年教育、与青少年沟通与教师就业之间的矛盾) für jungere Lehrerinnen und Lehrer: 首先这事关健康和能力(Leistungsfähigkeit)。年长的教师身体状况不再是如此充沛的。因为学校里的工作经常是累人(anstrengend)的， 年长的教师很容易患病。因此经常会发生以下情况：课程时不时的(ab und zu)停止(ausfallen)。 Erstens geht es um die Gesundheit und Leistungsfähigkeit. Ältere Lehrer sind körperlich nicht mehr so fit. Da die Arbeit in der Schule oft anstrengend ist, werden ältere Lehrer leicht krank. Deswegen passiert es oft, dass der Unterricht ab und zu ausfällt. 除此之外他们的收入高于年轻教师的收入。也就是说，学校必须支付(auszahlen)更多的钱，这些钱实际上应该被用于(bereitstellen)置购(Beschaffung)现代设备如电脑或学校基础设施的改善如操场或体育馆。所有的这些对教学质量以及学生身体健康的提高都是至关重要的。 Außerdem sind ihr Einkommen höher als das jüngeren Lehrer, d.h Die Schule muss mehr Geld auszahlen, das eigentlich für die Beschaffung moderner Geräte wie Computer oder die Verbesserung der Infrastruktur der Schule wie Sportplatz oder Sporthalle bereitgestellt werden soll. All das ist besonders wichtig für die Erhöhung von Lehrqualität und körperliche Gesundheit der Schüler. 相反地，与年长的教师相比尽管年轻的教师有较少的教学经验，但是年轻的教师是活跃的(dynamisch)、这有益于(dienen zu)，他们同学生有好的联系。他们可以同学生谈论体育和时尚(Mode)。借此师生之间的关系将被深化(vertiefen)。 Im Vergleich dazu haben die jüngeren Lehrer zwar wenigere Lehrerfahrungen im Vergleich zu älteren Lehrern, aber die jüngere Lehrer sind dynamisch. Dies dient dazu, dass sie einen guten Kontakt mit Schülern haben. Sie können über Sport oder Mode mit Schüler diskutieren. Dadurch wird die Beziehung zwischen Lehrern und Schülern vertieft. 从学生的视角来看，同年轻的教师交流更加容易。在学生的眼里年轻的教师向他们的大哥哥或大姐姐。因此学生会同年轻的教师讲出他们的顾虑。处于学生的这种角度青年教师是不可或缺的（unentbehrlich） Aus der Sicht der Schüler ist es leichter, mit jüngeren Lehrern zu kommunizieren. In den Augen der Schüler sind die jüngeren Lehrer wie ihre ältere Brüder oder Schwester. Deswegen wollen Schüler ihre Sorgen bei jüngeren Lehrern aussprechen. Aus der Aspekt der Schulen sind die jüngen Lehrer unentbehrlich. 除此之外年轻的教师对现代科技保持着开放的态度(gegenüber aufgeschlossen stehen)。他们可以通过互联网快速的更新他们的知识，因为他们连续地使用电脑和互联网工作。通过互联网他们可以找到(herausfinden)高新技术或者新的点子，他们使用这些以使课程丰富(bereichern)。借此学生有机会获得(schaffen)现代科技的概况(Überblick)并更有动力去学习。 Außerdem stehen jüngere Lehrer der modernen Technik gegenüber aufgeschlossen. Sie können ihre Kenntnis durch Internet schnell erneuern, weil sie stöndig mit Computer und Internet arbeiten. Durch das Internet können sie High-Technick oder neue Idee herausfinden, mit der sie Unterricht bereichern. Dabei haben die Schüler die Möglichkeit, einen Überblick über die moderne Technik zu schaffen und mehr zum Lernen motiviert zu werden. 现如今可以观察到，新兴媒体是基础教育和高级教育完整的（integral）组成部分(Bestandteil)。青年教师有将新知识、新的思考方式带入教育的能力。这的前提是来自互联网、电脑以及其他现代媒体的知识。因此这些都是必要的，因为学生今后不论是在大学还是在职业生活中都需要这种能力（Fertigkait）。除此之外通过安置（Einsatz)现代媒体更生动（lebendig）、更有吸引力。学生会更有动力学习，实际上这将对学业成绩有所贡献。 Zurziet ist es zu beobachten, dass die neuen Medien ein integraler Bestandteil der Grund- und Hochschulausbilung ist. Die jüngen Lehrer haben die Fähigkeit, neues Wissen und neue Dankenweise in die Ausbildung einzubringen. Die Voraussetzung dafür sind die Kenntnisse von Internet, Computer und dem kompetenten Umgang mit anderen modernen Medien. All das ist deswegen notwendig, weil die Schüler später sowohl an der Hochschule als auch in ihrem Berufsleben die Fertigkeit brauchen. Außerdem wird der Unterricht durch den Einsatz von modernen Medien lebendiger und attraktiver. Die Schüler werden noch besser zum Lernen motiviert, was wesentlich zur Schulleistungen beiträgt. 首先这是可能的：年长的教师会发现理解、得到新的点子十分困难。他们中很少有人通过互联网收集学生感兴趣的信息。除此之外他们经常把偶尔提出古怪（seltsam）问题的学生视为问题儿童（problematische Kinder）。 Zuerst ist es möglich, dass ältere Lehrer es sehr schwer finden, neue Ideen zu verstehen und zu erhalten. Selten sammeln sie durch das Internet die Informationen, die die Schüler interessieren. Auch halten sie oft die Schüler für problematische Kinder, die ab und zu einige seltsame Fragen stellen. für ältere Lehrerinnen und Lehrer: 年长的教师可以使用许多经验和知识。在学生为结业考试的准备过程年长的教师可以稍微更好地帮助。除此之外不排除(ausschließen)，按照大多数家长的意见年长的教师是值得信任的（zuverlässig）、可靠的(verantwortlich)。 Die älteren Lehrer verfügen über viele Erfahrungen ","date":"2020-07-15","objectID":"/testdaf-reference/:15:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"十六、营养摄入教学科目(中小学课程设置与青少年饮食习惯的培养) Pro: 学校在儿童教育工程中扮演着重要的角色。学生，尤其是小学生，会接受老师说的，作为父母所要求的。 Die Schule spielt eine sehr wichtige Rolle bei der Kindererziehung. Die Schulkinder, besonders in der Grundschule, akzeptieren eher das, was die Lehrer sagen, als das, was die Eltern auffordern. 除此之外儿童只有当认识到超重的潜在的（latent）危险时才倾向于（zu D. neigen）健康的饮食习惯。他们主要在学校学习这些理论。 Außerdem neigen die Kinder zu der gesunden Essgewohnheit nur, wenn sie die Ursachen bzw. das latente Risiko vom Übergewicht erkennen. Und diese Theorien lernen sie haupsächlich in der Schule. 学生经常相互比较并效仿（nachmachen）其他的学生。在学校他们一直交换他们的时髦的东西（die Sachen, die im Trend stehen）的观点和信息，尤其是小吃和快餐如薯片和汉堡这类容易导致超重的东西。当学校采取传授-管控措施时，儿童可以更好地发展。 Die Schulkinder vergleichen sich oft miteinander und machen den anderen Mitschülern nach. In der Schule tauschen sie immer ihre Meinungen und Informationen über die Sachen, die im Trend stehen, besonders über Snacks und Fastfood wie Kartoffeln Chips und Hamburger, die leicht zu Übergewicht führen können. Wenn Schule die Vermittlungs- und Kontrollefunktion übernimmt, können sich Kinder besser entwickeln. Kontra: 儿童的饮食习惯是诸如媒体和父母等不同因素的融合（Zusammenspiel）。因为儿童通常模仿他们父母的饮食习惯和生活方式，或通过媒体里的广告简单的接受甜食和快餐。 Die Essgewohnheit der Kinder ist ein Zusammenspiel verschiedener Faktoren wie Medien und Eltern. Denn die Kinder ahmen normalerweise die Essgewohnheit und die Lebensweise ihrer Eltern nach oder akzeptieren einfach Süßigkeiten und Fastfood durch Werbungen in Medien. 学生呆在他们父母身边远比呆在学校时间长。他们在家吃早餐晚餐。营养学对儿童来讲也是一份附加的负担。当这门营养学专业是必修的（obligatorisch）时候，学生必须花费时间（Zeit nehmen）学习一些其他的东西并为考试做准备（sich auf A. vorbereiten）。放学后学生有太多的作业，以至于他们拥有为体育的更少的时间，当他们必须写新的专业的附加的任务或背诵。 Die Schulkinder bleiben bei ihren Eltern viel länger als in der Schule. Sie frühstücken und Abend essen zu Hause. Weiterhin ist das Fach Ernährung eine zusätzliche Belastung für die Kinder. Wenn das Schulfach Ernährung obligatorisch ist, müssen sich die Schulkinder noch Zeit nehmen, um etwas zu lernen und sich auf die Prüfung vorzubereiten, dabei verlieren sie aber viel Zeit für die Bewegung. Nach der Schule haben Kinder zu viele Hausaufgaben, so dass sie noch weniger Zeit für Sport haben, wenn sie zusätzlich Aufgaben für das neue Fach schreiben oder auswendig lernen müssen. 父母应该亲自照顾他们儿童的营养。父母在家里决定儿童吃什么。当父母经常带着他们的孩子去麦当劳，老师在课堂上所阐述(erzählen)的快餐的坏的作用完全不适用（Es nützt gar nicht, dass）。 Die Eltern soll sich um die gesunde Ernährung ihrer Kinder kümmern. Was die Kinder essen, entscheiden sich die Eltern zu Hause. Wenn die Eltern oft mit ihren Kindern in McDonald´s gehen, nützt es gar nicht, dass die Lehrer im Unterricht etwas von schlechter Auswikung des Fastfoods erzählen. 很多教师是此方面未被认证的（zu D. qualifizieren）。因为为这门专业必须是系统学习过营养科学的老师才能被雇用。 Viele Lehrer sind nicht dazu qualifiziert. Denn für das Scuhlfach Ernährung müssen Lehrer angestellt werden, die systematisch die Ernährungswissenschaften studiert haben. ","date":"2020-07-15","objectID":"/testdaf-reference/:16:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"十七、移民话题(多元文化领域问题) Pro: 移民对许多在发达国家的企业来讲是一份后备力量（Nothilfe）。这些国家因为持续低下的（andauernd niedriger）出生率而缺少劳动力。这如今对企业和发达国家的一个巨大的障碍（Barrierer）。移民会对此有帮助。 Die Migranten sind eine Nothilfe für viele Unternehmen in den Industrieländern. Wegen andauernd niedrieger Geburtenrate mangelt es diesen Ländern an Arbeitskräften. Dies ist jetzt schon eine große Barriere für die Entwicklung der Unternehmen und der Industrieländer. Dabei helfen die Migranten. 尤其要提到的是（Besonders zu erwähnen ist, dass…），许多移民受过职业教育或有已结束的高校教育。因此他们可以为许多企业和社会的发展做杰出的（hervorragend）贡献。 Besonders zu erwähnen ist, dass viele Migranten beruflich ausgebildet sind oder eine abgeschlossene Hochschulausbildung haben. Deswegen können sie hervorragenden Beitrag zur Entwicklung vieler Unternehmen und der Gesellschaft leisten. 他们也给他们迁往的国家带来了多样的文化。从此本地人尤其获益良多。因为他们整日同来自全世界的人一同生活，他们有机会私下打听外来文化和其他的心性。这对一个国家、一个民族的全球化来说是一个重要的前提之一。 Weiterhin bringen sie dem Land, in das sie einwandern, viefältige Kultur. Davon profitieren die Einheimischen besonders viel. Da sie im Alltag mit Menschen aus aller Welt zusammen leben, haben sie die Möglichkeit, sich genau und persönlich über die fremde Kultur und andere Mentalität zu informieren. Das ist eine der wichtigen Voraussetzung für eine Globalisierung eines Landes und eines Volkes. 移民经常接过（übernehmen）本地人（Einheimische）不愿做的工作。一个典型的例子是垃圾清理（Müllentsorgung）。一些移民在东道国也从事商业（Geschäfte machen）并借此为本地人创造新的工作岗位。在这个意义上（In diesem Sinn）人可以说，移民为东道国的经济做了大的贡献（Beitrag zu D. leisten）并扮演着一个不可或缺的角色。 Die Migranten übernehmen oft die Aufgaben, die die Einheimischen nicht machen wollen. Ein typisches Beispiel ist die Müllentsorgung. Manche Migranten machen auch Geschäfte im Gastland und schaffen damit auch neue Arbeitsplätze für die Einheimischen. In diesem Sinn kann man wohl sagen, dass die Migranten einen großen Beitrag zur Wirtschafsentwicklung des Gastlandes leisten und eine unentbehrliche Rolle spielen. 在发达国家有许多人，他们已经在那里学习或生活过。他们现在搬去（auswandern）另一个国家，因为他们要在一个有着纯净空气的安静的生活空间居住。他们也将技术和心性（Mentalität）带到了东道国。这造成了，在发展中国家的人们也有机会打听最新的研究情况。世界范围的全球化进程便是如此工作的。 Es gibt viele Menschen in den Industrieländern, die dort studiert und gelebt haben. Sie wandern nun in ein anderes Land aus, weil sie im ruhigen Lebensraum mit sauberer Luft wohnen wollen. Sie bringen auch Technik und Mentalität in das Gastland. Dies führt dazu, dass die Menschen in den Entwicklungsland auch die Möglichkeit haben, sich über den neusten Forschungsstand zu informieren. So funktioniert die Globalisierung weltweit. Kontra: 东道国（Gastland）的经济会被或多或少的影响，如果移民将他们的钱待会他们的祖国。 Die Wirtschaft im Gastland wird mehr oder weniger beeinflusst, wenn die Migranten ihr Geld nach eigner Heimat mitbringen. ","date":"2020-07-15","objectID":"/testdaf-reference/:17:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"十八、 工作的孩子(学习负担加重问题、青少年是否应该了解社会问题) Pro: 伙子和姑娘的自立能力在工作过程中小扮演着十分重要的角色。 Die Selbstständigkeit bei der Arbeit von Jungen un Mädchen spielt eine wichtige Rolle. 不可忽视的是（Es sit nicht auszuschließen, dass…），家庭通过儿童工作经济上稍微可以减轻一些。 Es ist nicht auszuschließen, dass die Familie durch Arbeit von Kindern finanziell ein bisschen erleichtert werden kann. Kontra: 显而易见的是（Es liegt klar aif der Hand, dass），因为工作儿童错失了（verpassen）有价值的选择：被系统地（systematisch）教育，如果他们中断学校教育（Schulbildung abbrechen）并工作。如果一个人缺失了基础的学校教育，这将促进（贬义），文盲率（Analphabetenquote）在这个国家会提高（sich erhöhen）。 Es liegt klar auf der Hand, dass Kinder wegen Arbeit wertvolle Chance verpassen, systematisch ausgebildet zu werden, wenn sie Schulbildung abbrechen und arbeiten. Dies trägt dazu bei, dass sich die Analphebetenquote in diesem Land erhöhen kann, wenn einem die gründliche Schulausbildung fehlt. 长远（Ferne）来看健康方面的损伤作为后果也不能被无视。因为差劲的工作条件和沉重的负担（Belastung）儿童经常承受特定的疾病。但一家儿童工作的企业，并不关照儿童的健康，而仅仅是关照价钱。 Ferne sind gesundheitliche Schäden als Folge nicht zu vermeiden. Wegen der schlimmen Arbeitsbedingungen und schwerer Belastung leiden Kinder öfter an bestimmten Krankheiten. Aber ein Betrieb, der Kinder beschäftigt, kümmert sich nicht um die Gesundheit der Kinder, sondern nur um das Geld. 除此之外儿童工作将会被支付很差劲的薪水。因为他们只做简单的工作（Arbeit leisten）。他们挣得的，只能很少的帮助减轻家庭的经济负担。 Außerdem wird Kinderaibeit sehr schlecht bezahlt. Denn sie leisten nur einfache Arbeit. Was sie verdienen, hilft aber nur wenig, die Familie finanziell zu entlasten. 儿童在危险且剥削性质（ausbeuterisch）的条件下为微薄的（kümmerlich）收入辛苦工作（schupfen），并为此牺牲（opfern）了自己的健康。长远来看缺乏的教育是一个后果，但其中之一的原因就是儿童工作。因为家长无法承担（sich leisten）儿童上学或忽视了教育的意义。这些儿童得不到一份高薪工作所必要知识的机会。他们必须一生（das Leben lang）做简单的、廉价的工作。当这些儿童长大后，拥有了自己的家庭，也就是说拥有了自己的孩子，所有的一切都将如同他们的父母运行。以此产生了恶性循环（Teufelkreis）。为了打断（durchbrechen）这个恶性循环，父母必须如此想（auf A. kommen）：知识是对他们以及他们的孩子唯一的救赎（Rettung） Die Kinder schuften unter gefährlichen und ausbeuterischen Bedingungen für kümmerliches Einkommen und opfern dabei ihre Gesundheit. Ferne ist mangelnde Bildung eine Folge, aber auch eine der Ursachen von Kinderarbeit. Weil die Eltern sich einen Schulbesuch der Kinder nicht leisten können oder die Bedeutung der Bildung ignorieren, bekommen diese Kinder keine Gelegenheit, notwendige Kenntnisse für eine gut bezahlte Arbeit zu bekommen. Sie müssen das Leben lang eine einfache und schlecht bezahlte Arbeit machen. Wenn diese Kinder groß werden, eigene Familie bzw. eigene Kinder haben, läuft alles genauso wie bei ihren Eltern. So entsteht der Teufelskreis. Um diesen Teufelskreis zu durchbrechen, müssen die Eltern darauf kommen, dass das Wissen die einzige Rettung für sich und vor allem für ihre Kinder ist. ","date":"2020-07-15","objectID":"/testdaf-reference/:18:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"十九、留学是否有必要？ Pro: 积极（intensiv）接纳外国学生有诸多优点。因为外国学生来自不同文化，在德国高校的学生有机会在学习时间认识不同的文化和心性（Mentalität）。这将促进毕业生没有太大的困难而变得国际化。这种资质在一个全球化的世界是十分受欢迎的（gefragt）。通过毕业生的成功德国高校自然也会在专业世界（Fachwelt）完善它们的声誉（Ansehen）。 Daneben gibt es viele Vorteile für die intensive Aufnahme ausländischer Studierender. Da ausländische Studierende aus verschiedenen Kultur kommen, haben Studierende an deutschen Hochschulen die Möglichkeit, während der Studienzeit verschiedene Kurturen und Mentalitäten kennenzulernen. Dies trägt dazu bei, dass die Absolventen ohne große Schwierigkeiten international eingesetzt werden. In einer globalisierten Welt ist diese Qualifikation bei Unternehmen besonders gefragt. Durch den Erfolg der Absolventen verbessern deutsche Hochschulen natürlich auch ihr Ansehen in der Fachwelt. 此措施旨在于（sorgen dafür, dass…），德国高校可以同外国高校建立联系。因为许多外国学业申请者早已在他们的祖国结结束了学业。如果他们在德国高校学习的话，他们将会促进他们祖国的高校与德国高校之间的联系。通过国际合作德国高校必然打造他们的名声（Ruf schaffen）。 Diese Maßnahme sorgt dafür, dass die deutschen Hochschulen Kontakt mit ausländischen Hochschulen verknüpfen können. Denn viele ausländische Studienbewerber haben schon ein abgeschlossenes Studium in ihrem Heimat. Wenn sie an deutschen Hochschulen studieren, werden sie Kontakt zwischen Hochschule in ihrem Heimatland und deutscher Hochschule vermitteln. Durch internationale Zusammenarbeit werden deutsche Hochschulen sicherlich ihren Ruf schaffen. 外国学生带来了多样的文化。这将有助于德国高校和德国学生体验其他文化。通过与外国学生的交流德国学生不仅完善了他们的外语知识，也完善了他们的交流能力。在全球化的框架下越来越多的德国人为外国企业工作。因此这些德国学生在在校期间获得的文化经验可以对他们的职业生活十分重要。毕业生越成功，德国高校的形象（Image）也就越好。 Die ausländischen Studenten bringen vielfältige Kulturen mit sich. Dies trägt dazu bei, dass deutsche Hochschulen und Studierende andere Kulturen erfahren können. Durch die Kommunikation mit ausländischen Studierenden verbessern die deutschen Studenten nicht nur ihre Fremdsprachenkenntnisse, sondern auch ihre Kommunikationsfähigkeit. Im Rahmen der Globalisierung arbeiten immer mehr Deutsche für ausländische Firmen. Deshalb können die kulturellen Erfahrungen, die die deutschen Studenten an der Universität erworben haben, sehr wichtig für ihr Berufsleben sein. Je erfolgreicher die Absolventen sind, desto besser wird das Image deutscher Hochschulen. Kontra: 通过限制外国学生教授可以在学期、Vorlesung上传授更多的知识，当大多数参与者是德国学生的时候。 Durch die Begrenzung der ausländischen Studierenden können die Professoren in Seminar und Vorlesung mehr Kenntnisse vermitteln, wenn die meisten Teilnehmer deutsche Studierende sind. 随着外国学生数目的增长高校资源会紧缺。学生可能必须为学生公寓的一间房间或辅导时间的一个Termin等待稍长一些。但这些困难恰好对学生来讲是一个有意义的前提。此间他们应该尝试，用自己的力量解决问题、克服困难（Schwierigkeiten bewältigen）。这种自立能力对他们的职业生活尤为重要。因为在他们的职业中高校毕业生所有可能的任务和问题。在此他们的处理能力是一项决定性的资质，这也是德国高校应该重视(auf… großen Wert legen)的 (优点+缺点)Mit der zunehmenden Zahl ausländischer Studierenden werden die Ressourcen von Hochschulen knapp. Die Studierenden, müssen vielleicht ein bisschen länger auf ein Zimmer im Studentenwohnheim oder einen Termin für Sprechstunden warten. Aber solche Schwierigkeiten sind gerade eine sinnvolle Herausforderung für Studierende. Dabei sollen sie versuchen, mit eigener Kraft Probleme zu lösen und Schwierigkeiten selbst zu bewältigen. Diese Selbstständigkeit ist besonders wichtig für ihr Berufsleben. Denn in ihrem Beruf haben die Hochschulabsolventen alle möglichen Aufgaben und Probleme. Dabei ist ihre Handlungsfähigkeit eine entscheidene Qualifikation, worauf deutsche Hochschulen großen Wert legen sollen. ","date":"2020-07-15","objectID":"/testdaf-reference/:19:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":["Language"],"content":"二十、大学生实习是否重要？ Pro: 学生有很多机会，将他们的知识在实习中投入使用（in A umsetzen）。借此这成为了可能：在大学中被传授的理论，同实践建立联系（in Verbindung setzen）。他们也会学到，他们为何种问题使用何种理论，以及他们还缺乏什么。他们在此也可以发现（erfahren），人如何同同事、顾客以及科技设备（Anlage）打交道（umgehen）。 Studierende haben mehr Gelegenheiten, ihr Wissen in der Praxis umzusetzen. Dadurch sind die in der Lage, Theorie, die an der Uni vermittelt ist, mit Praxis in Verbindung zu setzen. Sie lernen auch, welche Theorie sie für welche praktische Probleme verwenden sollen und was ihnen noch fehlt. Sie können dabei noch erfahren, wie man mit Kollegen, Kunden oder technischer Anlage umgeht. 学生不仅会认识许多专业人士，也可以为今后的职业生活铺平道路（Weg zu … ebnen）。许多专业人士有着年长的实践经验，这些经验对高校毕业生的工作培训（Einarbeitung）很有价值而且恰恰（eben）不在任何教科书里。在实习期间他们也有机会，向雇主亲自介绍自己并建立一个积极的影响。这事关（sorgen für）一个相对顺利（reibungslos）的雇用。 Studierende können nicht nur viele Fachleute kennen lernen, sondern auch den Weg zu späten Berufsleben ebnen. Viele Fachleute haben langjährige praktische Erfahrungen. Diese Erfahrungen sind für die Einarbeitung der Hochschulabsolventen wertvoll und stehen eben nicht in irgendwelchen Lehrbüchern. Während des Praktikums haben sie auch die Möglichkeit, sich dem Arbeitgeber persönlich vorzustellen und dabei einen positiven Eindruck zu machen. Dies sorgt für eine relativ reibungslose Einstellung. 人可以找到很多使用他的知识的机会。当一位医学生面前有一位患者时，他便有可能实际使用他在教科书上读到过的治疗法。 Man kann mehr Chancen haben, Anwendung für sein Wissen finden. Wenn ein Mediziner einen Patienten vor sich hat, hat er die Möglichkeit, Therapie, die er in den Lehrbüchern gelesen hat, praktisch verwenden. 学生可以同企业建立(verknüpfen)紧密的联系(Kontakt zu)并认识许多专业人士。这可以变得很有帮助：当他们之后寻找一份工作的时候。一名想要在办公厅(Kanzlei)工作的法律学者可以通过实习打听判决(Gerichts)前的流程。这是赢得一场官司处理的第一步也是重要的一步(Schritt zu) Studierende können engen Kontakt zu Unternehmen verknüpfen und viele Fachleute kennen lernen. Das kann hilfreich sein, wenn sie später einen Job suchen. Durch Praktikum kann ein Rechtswissenschaftler, der in einer Kanzlei arbeiten möchte, sich über den Prozess vor Gericht informieren. Das wäre ein erster und wichtiger Schritt zum Gewinn einer Gerichtsverhandlung. Kontra: 有一些将实习生作为廉价劳动动力使用的企业。实习对高校毕业生来讲也是一个附加的时间浪费。 Es gibt einige Unternehmen, welche die Praktikanten als günstige Arbeitskräfte ausnutzen. Auch für Hochshculabsolventen ist ein Praktikum ein zusätzlicher Zeitaufwand. 一些实习生可以在学业结束后在企业花费一些更多的时间。除此之外一些实习生不可以凭他们的工作得到薪水。 Einige Praktikanten können nach ihrem Studium bei Unternehmen ein bisschen mehr Zeit aufwenden. Außerdem können manche Praktikanten für ihre Arbeit kein Geld bekommen. ","date":"2020-07-15","objectID":"/testdaf-reference/:20:0","tags":["German"],"title":"TestDaF Arguments ( German / zh-CN )","uri":"/testdaf-reference/"},{"categories":null,"content":"+++ +++ ","date":"0001-01-01","objectID":"/search/:0:0","tags":null,"title":"Search","uri":"/search/"}]